"""Postgres-backed repository for the Learning context."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Iterable, List, Optional, Sequence
import json
import os
import re
from uuid import UUID

try:  # pragma: no cover -- optional dependency in some environments
    import psycopg
    from psycopg import Connection
    from psycopg.types.json import Json

    HAVE_PSYCOPG = True
except Exception:  # pragma: no cover
    psycopg = None  # type: ignore
    Json = None  # type: ignore
    Connection = Any  # type: ignore
    HAVE_PSYCOPG = False


def _default_limited_dsn() -> str:
    host = os.getenv("TEST_DB_HOST", "127.0.0.1")
    port = os.getenv("TEST_DB_PORT", "54322")
    return f"postgresql://gustav_limited:gustav-limited@{host}:{port}/postgres"


def _dsn() -> str:
    env = (os.getenv("GUSTAV_ENV", "dev") or "dev").lower()
    candidates = [
        os.getenv("LEARNING_DATABASE_URL"),
        os.getenv("LEARNING_DB_URL"),
        os.getenv("DATABASE_URL"),
    ]
    # Only allow default limited DSN implicitly in non-prod environments (dev/test)
    if env != "prod":
        candidates.append(_default_limited_dsn())
    for candidate in candidates:
        if candidate:
            return candidate
    raise RuntimeError("Database DSN unavailable for Learning repo")


@dataclass
class SubmissionInput:
    course_id: str
    task_id: str
    student_sub: str
    kind: str
    text_body: Optional[str]
    storage_key: Optional[str]
    mime_type: Optional[str]
    size_bytes: Optional[int]
    sha256: Optional[str]
    idempotency_key: Optional[str]


class DBLearningRepo:
    """Persistence adapter used by Learning use cases."""

    def __init__(self, dsn: Optional[str] = None) -> None:
        if not HAVE_PSYCOPG:
            raise RuntimeError("psycopg3 is required for DBLearningRepo")
        self._dsn = dsn or _dsn()
        user = self._dsn_username(self._dsn)
        allow_override = str(os.getenv("ALLOW_SERVICE_DSN_FOR_TESTING", "")).lower() == "true"
        if user != "gustav_limited" and not allow_override:
            raise RuntimeError("LearningRepo requires gustav_limited DSN")

    @staticmethod
    def _dsn_username(dsn: str) -> str:
        from urllib.parse import urlparse

        try:
            parsed = urlparse(dsn)
            if parsed.username:
                return parsed.username
        except Exception:
            pass
        match = re.match(r"^[a-z]+://(?P<u>[^:]+):?[^@]*@", dsn or "")
        return match.group("u") if match else ""

    def _set_current_sub(self, cur, sub: str) -> None:
        cur.execute("select set_config('app.current_sub', %s, true)", (sub,))

    # ------------------------------------------------------------------
    def list_released_sections(
        self,
        *,
        student_sub: str,
        course_id: str,
        include_materials: bool,
        include_tasks: bool,
        limit: int,
        offset: int,
    ) -> List[dict]:
        course_uuid = str(UUID(course_id))
        with psycopg.connect(self._dsn) as conn:
            with conn.cursor() as cur:
                self._set_current_sub(cur, student_sub)
                cur.execute(
                    "select exists(select 1 from public.course_memberships where course_id=%s and student_id=%s)",
                    (course_uuid, student_sub),
                )
                if not bool(cur.fetchone()[0]):
                    raise PermissionError("not_course_member")

                self._set_current_sub(cur, student_sub)
                cur.execute(
                    """
                    select section_id::text,
                           section_title,
                           section_position,
                           unit_id::text,
                           course_module_id::text
                      from public.get_released_sections_for_student(%s, %s, %s, %s)
                    """,
                    (student_sub, course_uuid, int(limit), int(offset)),
                )
                rows = cur.fetchall()

            if not rows:
                raise LookupError("no_released_sections")

            sections: List[dict] = []
            for row in rows:
                section_id = row[0]
                entry = {
                    "section": {
                        "id": section_id,
                        "title": row[1],
                        # Contract requires integer â‰¥ 1; fall back to 1 if DB position is NULL
                        "position": int(row[2]) if row[2] is not None else 1,
                    },
                    "materials": [],
                    "tasks": [],
                }
                if include_materials:
                    entry["materials"] = self._fetch_materials(conn, student_sub, course_uuid, section_id)
                if include_tasks:
                    entry["tasks"] = self._fetch_tasks(conn, student_sub, course_uuid, section_id)
                sections.append(entry)
            return sections

    def _fetch_materials(self, conn: Connection, student_sub: str, course_id: str, section_id: str) -> List[dict]:
        with conn.cursor() as cur:
            self._set_current_sub(cur, student_sub)
            cur.execute(
                """
                select id::text,
                       title,
                       kind,
                       body_md,
                       mime_type,
                       size_bytes,
                       filename_original,
                       storage_key,
                       sha256,
                       alt_text,
                       material_position,
                       created_at_iso,
                       updated_at_iso
                  from public.get_released_materials_for_student(%s, %s, %s)
                """,
                (student_sub, course_id, section_id),
            )
            rows = cur.fetchall()
        materials: List[dict] = []
        for row in rows:
            materials.append(
                {
                    "id": row[0],
                    "title": row[1],
                    "kind": row[2],
                    "body_md": row[3],
                    "mime_type": row[4],
                    "size_bytes": row[5],
                    "filename_original": row[6],
                    "storage_key": row[7],
                    "sha256": row[8],
                    "alt_text": row[9],
                    "position": int(row[10]) if row[10] is not None else None,
                    "created_at": row[11],
                    "updated_at": row[12],
                }
            )
        return materials

    def _fetch_tasks(self, conn: Connection, student_sub: str, course_id: str, section_id: str) -> List[dict]:
        with conn.cursor() as cur:
            self._set_current_sub(cur, student_sub)
            cur.execute(
                """
                select id::text,
                       instruction_md,
                       criteria,
                       hints_md,
                       due_at_iso,
                       max_attempts,
                       task_position,
                       created_at_iso,
                       updated_at_iso
                  from public.get_released_tasks_for_student(%s, %s, %s)
                """,
                (student_sub, course_id, section_id),
            )
            rows = cur.fetchall()
        tasks: List[dict] = []
        for row in rows:
            tasks.append(
                {
                    "id": row[0],
                    "instruction_md": row[1],
                    "criteria": list(row[2] or []),
                    "hints_md": row[3],
                    "due_at": row[4],
                    "max_attempts": row[5],
                    "position": int(row[6]) if row[6] is not None else None,
                    "created_at": row[7],
                    "updated_at": row[8],
                    "kind": "native",
                }
            )
        return tasks

    # ------------------------------------------------------------------
    def create_submission(self, data: SubmissionInput) -> dict:
        course_uuid = str(UUID(data.course_id))
        task_uuid = str(UUID(data.task_id))

        with psycopg.connect(self._dsn) as conn:
            with conn.cursor() as cur:
                self._set_current_sub(cur, data.student_sub)
                cur.execute(
                    "select exists(select 1 from public.course_memberships where course_id=%s and student_id=%s)",
                    (course_uuid, data.student_sub),
                )
                if not bool(cur.fetchone()[0]):
                    raise PermissionError("not_course_member")

                if data.idempotency_key:
                    cur.execute(
                        """
                        select id::text,
                               attempt_nr,
                               kind,
                               text_body,
                               mime_type,
                               size_bytes,
                               sha256,
                               analysis_status,
                               analysis_json,
                               feedback_md,
                               error_code,
                               to_char(created_at at time zone 'utc', 'YYYY-MM-DD"T"HH24:MI:SS"+00:00"'),
                               to_char(completed_at at time zone 'utc', 'YYYY-MM-DD"T"HH24:MI:SS"+00:00"')
                          from public.learning_submissions
                         where course_id = %s
                           and task_id = %s
                           and student_sub = %s
                           and idempotency_key = %s
                        """,
                        (course_uuid, task_uuid, data.student_sub, data.idempotency_key),
                    )
                    existing = cur.fetchone()
                    if existing:
                        return self._row_to_submission(existing)

                cur.execute(
                    """
                    select task_id::text,
                           section_id::text,
                           unit_id::text,
                           max_attempts
                      from public.get_task_metadata_for_student(%s, %s, %s)
                    """,
                    (data.student_sub, course_uuid, task_uuid),
                )
                meta = cur.fetchone()
                if not meta:
                    raise LookupError("task_not_visible")
                max_attempts = meta[3]
                criteria = self._fetch_task_criteria(cur, task_uuid, data.student_sub)

                cur.execute(
                    "select public.next_attempt_nr(%s, %s, %s)",
                    (course_uuid, task_uuid, data.student_sub),
                )
                attempt_nr = int(cur.fetchone()[0])
                if max_attempts is not None and attempt_nr > int(max_attempts):
                    raise ValueError("max_attempts_exceeded")

                feedback_md = self._render_feedback(data.kind, attempt_nr)
                analysis_json = self._build_analysis_payload(
                    kind=data.kind,
                    text_body=data.text_body,
                    storage_key=data.storage_key,
                    sha256=data.sha256,
                    criteria=criteria,
                )

                try:
                    cur.execute(
                        """
                        insert into public.learning_submissions (
                            course_id,
                            task_id,
                            student_sub,
                            kind,
                            text_body,
                            storage_key,
                            mime_type,
                            size_bytes,
                            sha256,
                            attempt_nr,
                            analysis_status,
                            analysis_json,
                            feedback_md,
                            error_code,
                            idempotency_key
                        )
                        values (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s,
                                'completed', %s, %s, null, %s)
                        returning id::text,
                                  attempt_nr,
                                  kind,
                                  text_body,
                                  mime_type,
                                  size_bytes,
                                  sha256,
                                  analysis_status,
                                  analysis_json,
                                  feedback_md,
                                  error_code,
                                  to_char(created_at at time zone 'utc', 'YYYY-MM-DD"T"HH24:MI:SS"+00:00"'),
                                  to_char(completed_at at time zone 'utc', 'YYYY-MM-DD"T"HH24:MI:SS"+00:00"')
                        """,
                        (
                            course_uuid,
                            task_uuid,
                            data.student_sub,
                            data.kind,
                            data.text_body,
                            data.storage_key,
                            data.mime_type,
                            data.size_bytes,
                            data.sha256,
                            attempt_nr,
                            # psycopg needs explicit Json wrapper to serialize dict payloads correctly.
                            Json(analysis_json) if Json and analysis_json is not None else analysis_json,
                            feedback_md,
                            data.idempotency_key,
                        ),
                    )
                    row = cur.fetchone()
                    conn.commit()
                except Exception as exc:
                    # If another in-flight request inserted with the same Idempotency-Key, reuse it
                    from psycopg import errors as _pg_errors  # type: ignore

                    if isinstance(exc, _pg_errors.UniqueViolation):
                        conn.rollback()
                        cur.execute(
                            """
                            select id::text,
                                   attempt_nr,
                                   kind,
                                   text_body,
                                   mime_type,
                                   size_bytes,
                                   sha256,
                                   analysis_status,
                                   analysis_json,
                                   feedback_md,
                                   error_code,
                                   to_char(created_at at time zone 'utc', 'YYYY-MM-DD"T"HH24:MI:SS"+00:00"'),
                                   to_char(completed_at at time zone 'utc', 'YYYY-MM-DD"T"HH24:MI:SS"+00:00"')
                              from public.learning_submissions
                             where course_id = %s and task_id = %s and student_sub = %s and idempotency_key = %s
                            """,
                            (course_uuid, task_uuid, data.student_sub, data.idempotency_key),
                        )
                        existing = cur.fetchone()
                        if existing:
                            row = existing
                        else:  # defensive: re-raise if we cannot recover
                            raise
                    else:
                        raise
        return self._row_to_submission(row)

    def list_submissions(
        self,
        *,
        student_sub: str,
        course_id: str,
        task_id: str,
        limit: int,
        offset: int,
    ) -> List[dict]:
        """Fetch the caller's submission history for a task.

        Intent:
            Encapsulate membership/visibility guards and stable ordering inside
            the persistence layer while keeping use cases framework-agnostic.

        Parameters:
            student_sub: Authenticated student's subject identifier.
            course_id: Course scope for the task, UUID string.
            task_id: Target task UUID.
            limit/offset: Pagination parameters (already clamped by use case).

        Permissions:
            Caller must be enrolled in the course and the section must be
            released; enforced via membership check and
            `get_task_metadata_for_student`.
        """
        course_uuid = str(UUID(course_id))
        task_uuid = str(UUID(task_id))

        with psycopg.connect(self._dsn) as conn:
            with conn.cursor() as cur:
                self._set_current_sub(cur, student_sub)
                cur.execute(
                    "select exists(select 1 from public.course_memberships where course_id=%s and student_id=%s)",
                    (course_uuid, student_sub),
                )
                if not bool(cur.fetchone()[0]):
                    raise PermissionError("not_course_member")

                cur.execute(
                    """
                    select task_id::text
                      from public.get_task_metadata_for_student(%s, %s, %s)
                    """,
                    (student_sub, course_uuid, task_uuid),
                )
                visible = cur.fetchone()
                if not visible:
                    raise LookupError("task_not_visible")

                cur.execute(
                    """
                    select id::text,
                           attempt_nr,
                           kind,
                           text_body,
                           mime_type,
                           size_bytes,
                           sha256,
                           analysis_status,
                           analysis_json,
                           feedback_md,
                           error_code,
                           to_char(created_at at time zone 'utc', 'YYYY-MM-DD"T"HH24:MI:SS"+00:00"'),
                           to_char(completed_at at time zone 'utc', 'YYYY-MM-DD"T"HH24:MI:SS"+00:00"')
                      from public.learning_submissions
                     where course_id = %s
                       and task_id = %s
                       and student_sub = %s
                     order by created_at desc, attempt_nr desc
                     limit %s offset %s
                    """,
                    (course_uuid, task_uuid, student_sub, int(limit), int(offset)),
                )
                rows = cur.fetchall()

        return [self._row_to_submission(row) for row in rows]

    @staticmethod
    def _render_feedback(kind: str, attempt: int) -> str:
        if kind == "text":
            return f"Attempt {attempt}: Thanks for your explanation."
        return f"Attempt {attempt}: Image submission received."

    def _fetch_task_criteria(self, cur, task_id: str, student_sub: str) -> Sequence[str]:
        """Load rubric criteria for the task while keeping RLS context intact."""
        self._set_current_sub(cur, student_sub)
        cur.execute("select criteria from public.unit_tasks where id = %s", (task_id,))
        row = cur.fetchone()
        if not row:
            return []
        criteria = row[0] or []
        if isinstance(criteria, list):
            return [str(entry).strip() for entry in criteria if str(entry).strip()]
        return []

    def _build_analysis_payload(
        self,
        *,
        kind: str,
        text_body: Optional[str],
        storage_key: Optional[str],
        sha256: Optional[str],
        criteria: Sequence[str],
    ) -> dict:
        """Produce the synchronous analysis stub used until ML integration."""
        if kind == "text":
            text = (text_body or "").strip()
        else:
            text = self._image_text_stub(storage_key, sha256)
        length = len(text)
        scores = self._build_scores(criteria, length)
        return {
            "text": text,
            "length": length,
            "scores": scores,
        }

    def _build_scores(self, criteria: Sequence[str], text_length: int) -> List[dict]:
        """Generate rubric-style scores with deterministic, easy-to-read values."""
        names = [c for c in criteria if c]
        if not names:
            names = ["Submission"]
        # Simple heuristic: longer answers receive slightly higher stub scores.
        base_score = 6 if text_length < 20 else 8
        scores: List[dict] = []
        for index, criterion in enumerate(names):
            score = min(10, base_score + min(index, 2))
            scores.append(
                {
                    "criterion": criterion,
                    "score": score,
                    "explanation": "Stubbed analysis until machine learning is integrated.",
                }
            )
        return scores

    @staticmethod
    def _image_text_stub(storage_key: Optional[str], sha256: Optional[str]) -> str:
        """Derive a deterministic textual placeholder for OCR output."""
        if storage_key:
            token = storage_key.split("/")[-1]
        elif sha256:
            token = sha256[:12]
        else:
            token = "image"
        return f"OCR placeholder for {token}"

    @staticmethod
    def _row_to_submission(row: Iterable[Any]) -> dict:
        analysis = row[8]
        if isinstance(analysis, str):
            try:
                analysis = json.loads(analysis)
            except Exception:  # pragma: no cover - defensive
                pass
        return {
            "id": row[0],
            "attempt_nr": int(row[1]),
            "kind": row[2],
            "text_body": row[3],
            "mime_type": row[4],
            "size_bytes": row[5],
            "sha256": row[6],
            "analysis_status": row[7],
            "analysis_json": analysis,
            "feedback": row[9],
            "error_code": row[10],
            "created_at": row[11],
            "completed_at": row[12],
        }
