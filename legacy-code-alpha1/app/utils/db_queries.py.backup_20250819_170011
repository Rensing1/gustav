# app/utils/db_queries.py

import sys
import os
import json

# Füge das übergeordnete Verzeichnis (app) zum Python-Pfad hinzu
# damit absolute Imports wie \'from ai.service...\' funktionieren
current_dir = os.path.dirname(os.path.abspath(__file__)) # Pfad zu /app/utils
app_dir = os.path.dirname(current_dir) # Pfad zu /app
if app_dir not in sys.path:
    sys.path.insert(0, app_dir)

# --- Normale Imports danach --- 
from supabase_client import get_supabase_service_client
from utils.session_client import get_user_supabase_client
from supabase import PostgrestAPIResponse
import streamlit as st
from datetime import datetime, timezone, date, timedelta
import traceback
import random
from typing import Dict, List, Optional, Tuple

# Mastery imports moved to function level to avoid import conflicts
#from ai.feedback import CombinedMasteryFeedbackModule
#from mastery.mastery_config import INITIAL_DIFFICULTY, STABILITY_GROWTH_FACTOR
#from utils.mastery_algorithm import calculate_next_review_state


# --- Kurs-bezogene Abfragen --- 

def get_courses_by_creator(creator_id: str) -> tuple[list | None, str | None]:
    """Holt alle Kurse (id, name, created_at) eines Lehrers."""
    if not creator_id:
        return [], None
    try:
        client = get_user_supabase_client()
        response = (
            client
            .table("course")
            .select("id, name, created_at")
            .eq("creator_id", creator_id)
            .order("created_at", desc=True)
            .execute()
        )
        if hasattr(response, "error") and response.error:
            return None, f"Fehler beim Abrufen der Kurse: {response.error.message}"
        return response.data, None
    except Exception as e:
        return None, f"Unerwarteter Python-Fehler beim Abrufen der Kurse: {e}"


def create_course(name: str, creator_id: str) -> tuple[dict | None, str | None]:
    """Erstellt einen neuen Kurs in der Datenbank.

    Returns:
        tuple: (Kurs-Daten als dict, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not name or not creator_id:
        return None, "Kursname und Ersteller-ID sind erforderlich."
    try:
        response = supabase_client.table('course').insert({
            'name': name,
            'creator_id': creator_id
        }).execute()

        # Direkte Prüfung auf data und error in der Antwort
        if response.data:
            created_course = response.data[0]
            
            # Füge den Ersteller auch zur course_teacher Tabelle hinzu
            teacher_response = supabase_client.table('course_teacher').insert({
                'course_id': created_course['id'],
                'teacher_id': creator_id
            }).execute()
            
            if hasattr(teacher_response, 'error') and teacher_response.error:
                # Log den Fehler, aber gib trotzdem den erstellten Kurs zurück
                print(f"Warnung: Konnte Ersteller nicht zu course_teacher hinzufügen: {teacher_response.error}")
            
            return created_course, None # Gib das erstellte Kurs-Objekt zurück
        elif hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Erstellen des Kurses: {response.error.message}"
            print(f"Fehler in create_course: {response.error}")
            return None, error_msg
        else:
            # Fallback für unerwartete Antworten ohne expliziten Fehler
            error_msg = "Unbekannter Fehler beim Erstellen des Kurses."
            print(f"Unerwartete Antwort in create_course: {response}")
            return None, error_msg
    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Erstellen des Kurses: {e}"
        print(f"Exception in create_course: {e}")
        return None, error_msg


# --- Nutzer-bezogene Abfragen ---

def get_users_by_role(role: str) -> tuple[list | None, str | None]:
    """Holt alle Benutzer (id, email, full_name) mit einer bestimmten Rolle direkt aus profiles.

    Returns:
        tuple: (Liste der Nutzer, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    try:
        response = supabase_client.table('profiles') \
                                .select('id, email, full_name') \
                                .eq('role', role) \
                                .order('email') \
                                .execute()
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Benutzer mit Rolle '{role}': {response.error.message}"
            print(f"Fehler in get_users_by_role({role}): {response.error}")
            return None, error_msg
        if hasattr(response, 'data'):
            return response.data, None
        else:
            error_msg = f"Unerwartete DB-Antwort beim Abrufen der Nutzer mit Rolle '{role}'."
            print(f"Unerwartete Antwort in get_users_by_role({role}): {response}")
            return None, error_msg
    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Abrufen der Benutzer mit Rolle '{role}': {e}"
        print(f"Exception in get_users_by_role({role}): {e}")
        return None, error_msg

def get_students_in_course(course_id: str) -> tuple[list | None, str | None]:
    """Holt alle Schüler (id, email, full_name), die in einem bestimmten Kurs eingeschrieben sind.

    Returns:
        tuple: (Liste der Schüler-Profile, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not course_id: return [], None
    try:
        client = get_user_supabase_client()
        response = client.table('course_student') \
                                .select('profiles(id, email, full_name)') \
                                .eq('course_id', course_id) \
                                .execute()
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Schüler im Kurs: {response.error.message}"
            print(f"Fehler in get_students_in_course({course_id}): {response.error}")
            return None, error_msg
        if hasattr(response, 'data'):
            student_profiles = []
            for item in response.data:
                if item.get('profiles'):
                    profile = item['profiles']
                    # Verwende E-Mail-Präfix als Fallback für den Namen
                    if not profile.get('full_name') or profile.get('full_name') == 'None':
                        email = profile.get('email', '')
                        profile['full_name'] = email.split('@')[0] if '@' in email else email
                    student_profiles.append(profile)
            return student_profiles, None
        else:
            error_msg = f"Unerwartete DB-Antwort beim Abrufen der Schüler im Kurs {course_id}."
            print(f"Unerwartete Antwort in get_students_in_course({course_id}): {response}")
            return None, error_msg
    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Abrufen der Schüler im Kurs {course_id}: {e}"
        print(f"Exception in get_students_in_course({course_id}): {e}")
        return None, error_msg

def get_teachers_in_course(course_id: str) -> tuple[list | None, str | None]:
    """Holt alle Lehrer (id, email, full_name), die einem bestimmten Kurs zugewiesen sind.

    Returns:
        tuple: (Liste der Lehrer-Profile, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not course_id: return [], None
    try:
        response = supabase_client.table('course_teacher') \
                                .select('profiles(id, email, full_name)') \
                                .eq('course_id', course_id) \
                                .execute()
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Lehrer im Kurs: {response.error.message}"
            print(f"Fehler in get_teachers_in_course({course_id}): {response.error}")
            return None, error_msg
        if hasattr(response, 'data'):
            teacher_profiles = [item['profiles'] for item in response.data if item.get('profiles')]
            return teacher_profiles, None
        else:
            error_msg = f"Unerwartete DB-Antwort beim Abrufen der Lehrer im Kurs {course_id}."
            print(f"Unerwartete Antwort in get_teachers_in_course({course_id}): {response}")
            return None, error_msg
    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Abrufen der Lehrer im Kurs {course_id}: {e}"
        print(f"Exception in get_teachers_in_course({course_id}): {e}")
        return None, error_msg

def add_user_to_course(course_id: str, user_id: str, role: str) -> tuple[bool, str | None]:
    """Fügt einen Schüler oder Lehrer zu einem Kurs hinzu.

    Returns:
        tuple: (True, None) bei Erfolg oder wenn bereits vorhanden, (False, Fehlermeldung) bei Fehler.
    """
    if not course_id or not user_id or not role:
        return False, "Kurs-ID, Benutzer-ID und Rolle sind erforderlich."
    table_name = 'course_student' if role == 'student' else 'course_teacher'
    column_name = 'student_id' if role == 'student' else 'teacher_id'
    try:
        response = supabase_client.table(table_name).insert({
            'course_id': course_id,
            column_name: user_id
        }).execute()

        if response.data:
            return True, None
        elif hasattr(response, 'error') and response.error:
            if "duplicate key value violates unique constraint" in response.error.message:
                 print(f"Benutzer {user_id} bereits in Kurs {course_id} ({role}).")
                 return True, None # Erfolg, da Zustand erreicht
            error_msg = f"Fehler beim Hinzufügen von {role} {user_id} zu Kurs {course_id}: {response.error.message}"
            print(f"Fehler in add_user_to_course: {response.error}")
            return False, error_msg
        else:
            error_msg = f"Unbekannter Fehler beim Hinzufügen von {role} zu Kurs."
            print(f"Unerwartete Antwort in add_user_to_course: {response}")
            return False, error_msg
    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Hinzufügen von {role} zu Kurs: {e}"
        print(f"Exception in add_user_to_course: {e}")
        return False, error_msg

def remove_user_from_course(course_id: str, user_id: str, role: str) -> tuple[bool, str | None]:
    """Entfernt einen Schüler oder Lehrer aus einem Kurs.

    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not course_id or not user_id or not role:
        return False, "Kurs-ID, Benutzer-ID und Rolle sind erforderlich."
    table_name = 'course_student' if role == 'student' else 'course_teacher'
    column_name = 'student_id' if role == 'student' else 'teacher_id'
    try:
        response = supabase_client.table(table_name) \
                                .delete() \
                                .eq('course_id', course_id) \
                                .eq(column_name, user_id) \
                                .execute()

        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Entfernen von {role} {user_id} aus Kurs {course_id}: {response.error.message}"
            print(f"Fehler in remove_user_from_course: {response.error}")
            return False, error_msg
        else:
            return True, None # Erfolg wenn kein Fehler
    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Entfernen von {role} aus Kurs: {e}"
        print(f"Exception in remove_user_from_course: {e}")
        return False, error_msg


# --- Lerneinheit-Kurs-Zuweisungs-Abfragen ---

def get_courses_assigned_to_unit(unit_id: str) -> tuple[list | None, str | None]:
    """Holt die IDs und Namen der Kurse, denen eine Lerneinheit zugewiesen ist.

    Returns:
        tuple: (Liste der zugewiesenen Kurse [{'id': ..., 'name': ...}], None) bei Erfolg,
               (None, Fehlermeldung) bei Fehler.
    """
    if not unit_id:
        return [], None

    try:
        response = supabase_client.table('course_learning_unit_assignment') \
                                .select('course(id, name)') \
                                .eq('unit_id', unit_id) \
                                .execute()

        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Kurszuweisungen für Einheit {unit_id}: {response.error.message}"
            print(f"Fehler in get_courses_assigned_to_unit: {response.error}")
            return None, error_msg

        if hasattr(response, 'data'):
            assigned_courses = [item['course'] for item in response.data if item.get('course')]
            return assigned_courses, None
        else:
            error_msg = f"Unerwartete Datenbankantwort beim Abrufen der Kurszuweisungen für Einheit {unit_id}."
            print(f"Unerwartete Antwort in get_courses_assigned_to_unit: {response}")
            return None, error_msg

    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Abrufen der Kurszuweisungen für Einheit {unit_id}: {e}"
        print(f"Exception in get_courses_assigned_to_unit: {e}")
        return None, error_msg

def assign_unit_to_course(unit_id: str, course_id: str) -> tuple[bool, str | None]:
    """Weist eine Lerneinheit einem Kurs zu.

    Returns:
        tuple: (True, None) bei Erfolg oder wenn bereits vorhanden, (False, Fehlermeldung) bei Fehler.
    """
    if not unit_id or not course_id:
        return False, "Lerneinheit-ID und Kurs-ID sind erforderlich."

    try:
        response = supabase_client.table('course_learning_unit_assignment').insert({
            'unit_id': unit_id,
            'course_id': course_id
        }).execute()

        if response.data:
            return True, None # Erfolg
        elif hasattr(response, 'error') and response.error:
            if "duplicate key value violates unique constraint" in response.error.message:
                 print(f"Zuweisung Einheit {unit_id} zu Kurs {course_id} existiert bereits.")
                 return True, None # Betrachte es als Erfolg
            else:
                error_msg = f"Fehler beim Zuweisen von Einheit {unit_id} zu Kurs {course_id}: {response.error.message}"
                print(f"Fehler in assign_unit_to_course: {response.error}")
                return False, error_msg
        else:
            error_msg = "Unbekannter Fehler beim Zuweisen der Lerneinheit."
            print(f"Unerwartete Antwort in assign_unit_to_course: {response}")
            return False, error_msg

    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Zuweisen der Lerneinheit: {e}"
        print(f"Exception in assign_unit_to_course: {e}")
        return False, error_msg

def unassign_unit_from_course(unit_id: str, course_id: str) -> tuple[bool, str | None]:
    """Entfernt die Zuweisung einer Lerneinheit von einem Kurs.

    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not unit_id or not course_id:
        return False, "Lerneinheit-ID und Kurs-ID sind erforderlich."

    try:
        response = supabase_client.table('course_learning_unit_assignment') \
                                .delete() \
                                .eq('unit_id', unit_id) \
                                .eq('course_id', course_id) \
                                .execute()

        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Entfernen der Zuweisung von Einheit {unit_id} aus Kurs {course_id}: {response.error.message}"
            print(f"Fehler in unassign_unit_from_course: {response.error}")
            return False, error_msg
        else:
            # Erfolg wird angenommen, wenn kein Fehler auftritt
            return True, None

    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Entfernen der Zuweisung: {e}"
        print(f"Exception in unassign_unit_from_course: {e}")
        return False, error_msg

# --- Abschnitt-bezogene Abfragen ---

def get_sections_for_unit(unit_id: str) -> tuple[list | None, str | None]:
    """Holt alle Abschnitte (id, title, order_in_unit, materials) einer Lerneinheit.

    Returns:
        tuple: (Liste der Abschnitte, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not unit_id: return [], None
    try:
        response = supabase_client.table('unit_section') \
                                .select('id, title, order_in_unit, materials, created_at') \
                                .eq('unit_id', unit_id) \
                                .order('order_in_unit', desc=False) \
                                .execute()

        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Abschnitte für Einheit {unit_id}: {response.error.message}"
            print(f"Fehler in get_sections_for_unit: {response.error}")
            return None, error_msg

        if hasattr(response, 'data'):
            data = response.data
            # Stelle sicher, dass 'materials' immer eine Liste ist, kein None
            for section in data:
                if section.get('materials') is None:
                    section['materials'] = []
            return data, None
        else:
            error_msg = f"Unerwartete DB-Antwort beim Abrufen der Abschnitte für Einheit {unit_id}."
            print(f"Unerwartete Antwort in get_sections_for_unit: {response}")
            return None, error_msg

    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Abrufen der Abschnitte für Einheit {unit_id}: {e}"
        print(f"Exception in get_sections_for_unit: {e}")
        return None, error_msg

# --- Abfragen für Lerneinheit-Kurs-Beziehung ---

def get_assigned_units_for_course(course_id: str) -> tuple[list | None, str | None]:
    """Holt die Lerneinheiten (id, title), die einem bestimmten Kurs zugewiesen sind.

    Returns:
        tuple: (Liste der Einheiten [{'id': ..., 'title': ...}], None) bei Erfolg,
               (None, Fehlermeldung) bei Fehler.
    """
    if not course_id: return [], None
    try:
        response = supabase_client.table('course_learning_unit_assignment') \
                                .select('learning_unit(id, title)') \
                                .eq('course_id', course_id) \
                                .execute()

        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Einheiten für Kurs {course_id}: {response.error.message}"
            print(f"Fehler in get_assigned_units_for_course: {response.error}")
            return None, error_msg

        if hasattr(response, 'data'):
            assigned_units = [item['learning_unit'] for item in response.data if item.get('learning_unit')]
            # Sortiere nach Titel für die Selectbox
            assigned_units.sort(key=lambda x: x.get('title', ''))
            return assigned_units, None
        else:
            error_msg = f"Unerwartete DB-Antwort beim Abrufen der Einheiten für Kurs {course_id}."
            print(f"Unerwartete Antwort in get_assigned_units_for_course: {response}")
            return None, error_msg

    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Abrufen der Einheiten für Kurs {course_id}: {e}"
        print(f"Exception in get_assigned_units_for_course: {e}")
        return None, error_msg


# --- Abfragen für Abschnitt-Freigabe ---

def get_section_statuses_for_unit_in_course(unit_id: str, course_id: str) -> tuple[dict | None, str | None]:
    """Holt den Veröffentlichungsstatus ({section_id: is_published}) für alle Abschnitte
       einer Einheit innerhalb eines bestimmten Kurses.

    Returns:
        tuple: (Dictionary {section_id: bool}, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not unit_id or not course_id: return {}, None # Leeres Dict ist gültig
    try:
        # Hole alle section_ids für die unit_id
        sections_response = supabase_client.table('unit_section') \
                                        .select('id') \
                                        .eq('unit_id', unit_id) \
                                        .execute()
        if hasattr(sections_response, 'error') and sections_response.error:
             raise Exception(f"Konnte Abschnitt-IDs nicht laden: {sections_response.error.message}")
        if not hasattr(sections_response, 'data'):
             raise Exception("Unerwartete Antwort beim Laden der Abschnitt-IDs.")

        section_ids = [s['id'] for s in sections_response.data]
        if not section_ids:
            return {}, None # Keine Abschnitte, also keine Status

        # Hole die Status für diese Abschnitte im spezifischen Kurs
        status_response = supabase_client.table('course_unit_section_status') \
                                        .select('section_id, is_published') \
                                        .eq('course_id', course_id) \
                                        .in_('section_id', section_ids) \
                                        .execute()

        if hasattr(status_response, 'error') and status_response.error:
            error_msg = f"Fehler beim Abrufen der Abschnitt-Status: {status_response.error.message}"
            print(f"Fehler in get_section_statuses_for_unit_in_course: {status_response.error}")
            return None, error_msg

        if hasattr(status_response, 'data'):
            # Erstelle ein Dict {section_id: is_published}
            status_dict = {item['section_id']: item['is_published'] for item in status_response.data}
            # Füge fehlende Abschnitte mit False hinzu (falls sie noch keinen Eintrag haben)
            for sec_id in section_ids:
                if sec_id not in status_dict:
                    status_dict[sec_id] = False
            return status_dict, None
        else:
            error_msg = "Unerwartete DB-Antwort beim Abrufen der Abschnitt-Status."
            print(f"Unerwartete Antwort in get_section_statuses_for_unit_in_course: {status_response}")
            return None, error_msg

    except Exception as e:
        error_msg = f"Fehler beim Ermitteln der Abschnitt-Status für Einheit {unit_id} in Kurs {course_id}: {e}"
        print(f"Exception in get_section_statuses_for_unit_in_course: {e}")
        return None, error_msg

def publish_section_for_course(section_id: str, course_id: str) -> tuple[bool, str | None]:
    """Veröffentlicht einen Abschnitt für einen Kurs (setzt is_published=true)."""
    if not section_id or not course_id: return False, "Abschnitt-ID und Kurs-ID erforderlich."
    try:
        # Upsert: Fügt ein oder aktualisiert, wenn Konflikt auf PK (course_id, section_id)
        response = supabase_client.table('course_unit_section_status').upsert({
            'course_id': course_id,
            'section_id': section_id,
            'is_published': True,
            'published_at': datetime.now().isoformat() # Zeitstempel setzen
        }).execute()

        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Veröffentlichen von Abschnitt {section_id} für Kurs {course_id}: {response.error.message}"
            print(f"Fehler in publish_section_for_course: {response.error}")
            return False, error_msg
        # Kein Fehler -> Erfolg (Upsert gibt nicht immer sinnvolle 'data' zurück)
        return True, None
    except Exception as e:
        error_msg = f"Unerwarteter Fehler beim Veröffentlichen von Abschnitt {section_id}: {e}"
        print(f"Exception in publish_section_for_course: {e}")
        return False, error_msg

def unpublish_section_for_course(section_id: str, course_id: str) -> tuple[bool, str | None]:
    """Zieht die Veröffentlichung eines Abschnitts für einen Kurs zurück (setzt is_published=false)."""
    if not section_id or not course_id: return False, "Abschnitt-ID und Kurs-ID erforderlich."
    try:
        # Nur Update, wenn Eintrag existiert. Wenn nicht, ist er eh nicht veröffentlicht.
        response = supabase_client.table('course_unit_section_status') \
                                .update({
                                    'is_published': False
                                    # 'published_at' könnte man auf NULL setzen oder ignorieren
                                }) \
                                .eq('course_id', course_id) \
                                .eq('section_id', section_id) \
                                .execute()

        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Zurückziehen von Abschnitt {section_id} für Kurs {course_id}: {response.error.message}"
            print(f"Fehler in unpublish_section_for_course: {response.error}")
            return False, error_msg
        # Kein Fehler -> Erfolg
        return True, None
    except Exception as e:
        error_msg = f"Unerwarteter Fehler beim Zurückziehen von Abschnitt {section_id}: {e}"
        print(f"Exception in unpublish_section_for_course: {e}")
        return False, error_msg

def get_student_courses(student_id: str) -> tuple[list | None, str | None]:
    """Holt die Kurse (id, name), in denen ein Schüler eingeschrieben ist.

    Returns:
        tuple: (Liste der Kurse [{'id': ..., 'name': ...}], None) bei Erfolg,
               (None, Fehlermeldung) bei Fehler.
    """
    if not student_id: return [], None
    try:
        # Wähle Kurs-Infos über die course_student Verknüpfungstabelle
        client = get_user_supabase_client()
        response = client.table('course_student') \
                                .select('course(id, name)') \
                                .eq('student_id', student_id) \
                                .execute()

        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Schüler-Kurse: {response.error.message}"
            print(f"Fehler in get_student_courses: {response.error}")
            return None, error_msg

        if hasattr(response, 'data'):
            # Struktur ist [{'course': {'id': ..., 'name': ...}}, ...]
            student_courses = [item['course'] for item in response.data if item.get('course')]
            # Sortiere nach Namen
            student_courses.sort(key=lambda x: x.get('name', ''))
            return student_courses, None
        else:
            error_msg = "Unerwartete DB-Antwort beim Abrufen der Schüler-Kurse."
            print(f"Unerwartete Antwort in get_student_courses: {response}")
            return None, error_msg

    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Abrufen der Schüler-Kurse: {e}"
        print(f"Exception in get_student_courses: {e}")
        return None, error_msg

def get_published_section_details_for_student(unit_id: str, course_id: str, student_id: str) -> tuple[list | None, str | None]:
    """Holt die Details (id, title, order, materials, tasks) ALLER Abschnitte einer Einheit,
       die für einen bestimmten Kurs veröffentlicht sind.
       Prüft auch, ob der Schüler bereits eine Einreichung für jede Aufgabe hat.

    Returns:
        tuple: (Liste von Abschnitt-Dicts, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
               Jedes Abschnitt-Dict enthält: {'id', 'title', 'order_in_unit', 'materials': [], 'tasks': []}
               Jedes Task-Dict enthält zusätzlich: 
                 {'submission_data': {...} or None, 'submission_obj': {...} or None}
    """
    if not all([unit_id, course_id, student_id]):
        return [], None

    try:
        # Schritt 1: Finde alle Section IDs, die für den Kurs veröffentlicht sind
        status_response = supabase_client.table('course_unit_section_status') \
                                        .select('section_id') \
                                        .eq('course_id', course_id) \
                                        .eq('is_published', True) \
                                        .execute()
        if hasattr(status_response, 'error') and status_response.error:
             raise Exception(f"Fehler beim Laden der veröffentlichten Abschnitt-IDs: {status_response.error.message}")
        if not hasattr(status_response, 'data'):
             raise Exception("Unerwartete Antwort beim Laden der veröffentlichten Abschnitt-IDs.")

        published_section_ids = [s['section_id'] for s in status_response.data]
        if not published_section_ids:
            return [], None # Keine Abschnitte veröffentlicht

        # Schritt 2: Hole die Details dieser veröffentlichten Abschnitte (inkl. Materialien)
        #             und sortiere sie nach ihrer Reihenfolge in der Einheit.
        #             Filtere gleichzeitig nach der unit_id zur Sicherheit.
        sections_response = supabase_client.table('unit_section') \
                                        .select('id, title, order_in_unit, materials') \
                                        .eq('unit_id', unit_id) \
                                        .in_('id', published_section_ids) \
                                        .order('order_in_unit', desc=False) \
                                        .execute()
        if hasattr(sections_response, 'error') and sections_response.error:
             raise Exception(f"Fehler beim Laden der Abschnitt-Details: {sections_response.error.message}")
        if not hasattr(sections_response, 'data'):
             raise Exception("Unerwartete Antwort beim Laden der Abschnitt-Details.")

        published_sections = sections_response.data
        # Stelle sicher, dass 'materials' immer eine Liste ist
        for section in published_sections:
             if section.get('materials') is None:
                 section['materials'] = []
             section['tasks'] = [] # Initialisiere leere Task-Liste

        if not published_sections:
             return [], None # Sollte nicht passieren, wenn IDs gefunden wurden, aber sicher ist sicher

        # Schritt 3: Hole alle Aufgaben für DIESE veröffentlichten Abschnitte
        # WICHTIG: Filtere Wissensfestiger-Aufgaben aus (is_mastery = false oder NULL)
        section_ids_for_tasks = [s['id'] for s in published_sections]
        tasks_response = supabase_client.table('task') \
                                      .select('id, section_id, instruction, task_type, order_in_section, is_mastery') \
                                      .in_('section_id', section_ids_for_tasks) \
                                      .or_('is_mastery.is.null,is_mastery.eq.false') \
                                      .order('order_in_section', desc=False) \
                                      .execute()
        if hasattr(tasks_response, 'error') and tasks_response.error:
             raise Exception(f"Fehler beim Laden der Aufgaben: {tasks_response.error.message}")
        if not hasattr(tasks_response, 'data'):
             raise Exception("Unerwartete Antwort beim Laden der Aufgaben.")

        tasks = tasks_response.data
        task_ids = [t['id'] for t in tasks]

        # Schritt 4: Hole alle Einreichungen des Schülers für DIESE Aufgaben
        submissions = {}
        submissions_full = {}  # Vollständige Submission-Objekte
        if task_ids: # Nur abfragen, wenn es Aufgaben gibt
            submissions_response = supabase_client.table('submission') \
                                              .select('*') \
                                              .eq('student_id', student_id) \
                                              .in_('task_id', task_ids) \
                                              .execute()
            if hasattr(submissions_response, 'error') and submissions_response.error:
                # Warnung statt Fehler, damit die Aufgaben trotzdem angezeigt werden
                print(f"Warnung: Fehler beim Laden der Einreichungen für Schüler {student_id}: {submissions_response.error.message}")
            elif hasattr(submissions_response, 'data'):
                for s in submissions_response.data:
                    submissions[s['task_id']] = s['submission_data']
                    submissions_full[s['task_id']] = s  # Speichere das vollständige Objekt


        # Schritt 5: Füge Aufgaben und Einreichungsstatus zu den Abschnitten hinzu
        task_map = {task['id']: task for task in tasks} # Schneller Zugriff über ID
        for section in published_sections:
            section_id = section['id']
            section_tasks_sorted = []
            for task_id, task in task_map.items():
                if task['section_id'] == section_id:
                     # Füge Info hinzu, ob eine Einreichung existiert
                     task['submission_data'] = submissions.get(task_id) # Ist None, wenn nicht vorhanden
                     task['submission_obj'] = submissions_full.get(task_id) # Vollständiges Objekt
                     section_tasks_sorted.append(task)
            # Sortiere die Tasks innerhalb des Abschnitts (obwohl schon aus DB sortiert, zur Sicherheit)
            section_tasks_sorted.sort(key=lambda t: (t.get('order_in_section') is None, t.get('order_in_section')))
            section['tasks'] = section_tasks_sorted


        return published_sections, None # Gib die Liste der angereicherten Abschnitte zurück

    except Exception as e:
        error_msg = f"Fehler beim Abrufen der Abschnitt-Details für Schüler {student_id}: {e}"
        print(f"Exception in get_published_section_details_for_student: {e}")
        return None, error_msg

def create_submission(student_id: str, task_id: str, submission_data: dict | str) -> tuple[dict | None, str | None]:
    """Erstellt eine neue Einreichung in der Datenbank. Stößt KEINE KI an."""
    if not student_id or not task_id or submission_data is None:
        return None, "Schüler-ID, Aufgaben-ID und Lösung sind erforderlich."

    submission_payload = submission_data
    if isinstance(submission_data, str):
        submission_payload = {"text": submission_data}

    try:
        print(f"Versuche Einreichung zu speichern für student {student_id}, task {task_id}...")
        
        # NEU: Prüfe max_attempts und zähle bisherige Versuche
        # 1. Hole task info mit max_attempts
        task_response = supabase_client.table('task').select('max_attempts').eq('id', task_id).single().execute()
        if hasattr(task_response, 'error') and task_response.error:
            return None, f"Fehler beim Abrufen der Aufgabeninformationen: {task_response.error.message}"
        
        max_attempts = task_response.data.get('max_attempts', 1) if task_response.data else 1
        
        # 2. Zähle bisherige Einreichungen
        count_response = supabase_client.table('submission').select('id').eq('student_id', student_id).eq('task_id', task_id).execute()
        if hasattr(count_response, 'error') and count_response.error:
            return None, f"Fehler beim Zählen der bisherigen Einreichungen: {count_response.error.message}"
        
        current_attempts = len(count_response.data) if count_response.data else 0
        attempt_number = current_attempts + 1
        
        # 3. Prüfe ob noch Versuche übrig sind
        if attempt_number > max_attempts:
            return None, f"Maximale Anzahl an Versuchen ({max_attempts}) bereits erreicht."
        
        # Schritt 4: Führe den INSERT mit nur den benötigten Feldern aus
        # Queue-Felder werden durch DB-DEFAULT-Values gesetzt
        response: PostgrestAPIResponse = supabase_client.table('submission').insert({
            'student_id': student_id,
            'task_id': task_id,
            'submission_data': submission_payload,
            'attempt_number': attempt_number
            # Queue-Felder NICHT explizit setzen - DB DEFAULT values verwenden
            # WICHTIG: Gib die eingefügten Daten zurück, falls die API es erlaubt
            # Standard ist oft 'minimal', was nur Header zurückgibt.
            # 'representation' gibt die volle Zeile zurück.
        }, returning="representation").execute() # returning="representation" anfordern

        print(f"DB Antwort nach INSERT: {response}")

        # Schritt 2: Prüfe das Ergebnis des INSERT
        if hasattr(response, 'data') and response.data:
            # Bei returning="representation" sollte data eine Liste mit dem Objekt sein
            if isinstance(response.data, list) and len(response.data) > 0:
                new_submission = response.data[0]
                print(f"Einreichung {new_submission.get('id', 'NO_ID?')} erfolgreich gespeichert.")
                # --- KEIN KI-Aufruf hier ---
                return new_submission, None # Erfolg, gib das neue Objekt zurück
            else:
                # Daten vorhanden, aber nicht im erwarteten Format
                error_msg = "Einreichung gespeichert, aber unerwartetes Datenformat von DB erhalten (erwartet: Liste mit Objekt)."
                print(f"{error_msg} Daten: {response.data}")
                return None, error_msg

        elif hasattr(response, 'error') and response.error:
             # Fehlerbehandlung für DB-Fehler
             if "submission_student_task_attempt_unique" in response.error.message:
                 return None, f"Du hast bereits {current_attempts} Versuche für diese Aufgabe eingereicht."
             else:
                error_msg = f"Fehler beim Speichern der Einreichung: {response.error.message}"
                print(f"Fehler in create_submission: {error_msg}")
                return None, error_msg
        else:
            # Unerwarteter Fall
            error_msg = "Unbekannter Fehler beim Speichern der Einreichung (keine Daten, kein Fehler)."
            print(f"Unerwartete Antwort in create_submission: {response}")
            return None, error_msg

    except Exception as e:
        error_msg = f"Unerwarteter Python-Fehler beim Speichern der Einreichung: {e}"
        print(f"Exception in create_submission: {traceback.format_exc()}")
        return None, error_msg
# --- Ende create_submission ---

def get_submission_history(student_id: str, task_id: str) -> tuple[list | None, str | None]:
    """Holt alle Einreichungen eines Schülers für eine Aufgabe, sortiert nach attempt_number."""
    if not student_id or not task_id:
        return None, "Student-ID und Task-ID sind erforderlich."
    
    try:
        response = supabase_client.table('submission') \
                                .select('*') \
                                .eq('student_id', student_id) \
                                .eq('task_id', task_id) \
                                .order('attempt_number', desc=False) \
                                .execute()
        
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Submission-Historie: {response.error.message}"
            print(f"Fehler in get_submission_history: {error_msg}")
            return None, error_msg
        
        return response.data if response.data else [], None
        
    except Exception as e:
        error_msg = f"Unerwarteter Fehler beim Abrufen der Submission-Historie: {e}"
        print(f"Exception in get_submission_history: {e}")
        return None, error_msg

def get_remaining_attempts(student_id: str, task_id: str) -> tuple[int | None, str | None]:
    """Gibt zurück, wie viele Versuche noch übrig sind für eine Aufgabe."""
    if not student_id or not task_id:
        return None, "Student-ID und Task-ID sind erforderlich."
    
    try:
        # Hole max_attempts von task
        task_response = supabase_client.table('task').select('max_attempts').eq('id', task_id).single().execute()
        if hasattr(task_response, 'error') and task_response.error:
            return None, f"Fehler beim Abrufen der Aufgabeninformationen: {task_response.error.message}"
        
        max_attempts = task_response.data.get('max_attempts', 1) if task_response.data else 1
        
        # Zähle bisherige Einreichungen
        count_response = supabase_client.table('submission').select('id').eq('student_id', student_id).eq('task_id', task_id).execute()
        if hasattr(count_response, 'error') and count_response.error:
            return None, f"Fehler beim Zählen der bisherigen Einreichungen: {count_response.error.message}"
        
        current_attempts = len(count_response.data) if count_response.data else 0
        remaining = max_attempts - current_attempts
        
        return remaining, None
        
    except Exception as e:
        error_msg = f"Unerwarteter Fehler beim Berechnen der verbleibenden Versuche: {e}"
        print(f"Exception in get_remaining_attempts: {e}")
        return None, error_msg

# --- Funktionen für KI-Verarbeitung ---

def get_task_details(task_id: str) -> tuple[dict | None, str | None]:
    """Holt relevante Details (instruction, criteria) für eine Aufgabe."""
    if not task_id:
        return None, "Task-ID fehlt."
    try:
        response = (
            supabase_client
            .table("task")
            .select("instruction, assessment_criteria, solution_hints, is_mastery")
            .eq("id", task_id)
            .maybe_single()
            .execute()
        )
        if hasattr(response, "error") and response.error:
            return None, f"DB Fehler beim Holen der Task-Details für ID {task_id}: {response.error.message}"
        if response.data:
            return response.data, None
        else:
            return None, f"Aufgabe mit ID {task_id} nicht gefunden."
    except Exception as e:
        return None, f"Python Fehler beim Holen der Task-Details für ID {task_id}: {e}"


def update_submission_ai_results(
    submission_id: str, 
    criteria_analysis: str | None, 
    feedback: str | None, 
    rating_suggestion: str | None,
    feed_back_text: str | None = None,
    feed_forward_text: str | None = None
) -> tuple[bool, str | None]:
    """Aktualisiert eine Einreichung mit den Ergebnissen der KI.
       Verwendet den Service Role Client, um RLS zu umgehen.
       
       Args:
           submission_id: ID der Einreichung
           criteria_analysis: JSON-String der Kriterien-Analyse
           feedback: Kombiniertes Feedback (für Abwärtskompatibilität)
           rating_suggestion: Bewertungsvorschlag
           feed_back_text: Feed-Back Teil (Wo stehe ich?)
           feed_forward_text: Feed-Forward Teil (Nächste Schritte)
    """
    if not submission_id: return False, "Submission-ID fehlt."

    # Hole den Service Client
    service_client = get_supabase_service_client()
    if service_client is None:
        return False, "Supabase Service Client konnte nicht initialisiert werden (SERVICE_ROLE_KEY fehlt?)."

    try:
        update_data = {}
        if criteria_analysis is not None: 
            update_data['ai_criteria_analysis'] = criteria_analysis
        if feedback is not None:
            update_data['ai_feedback'] = feedback
            update_data['feedback_generated_at'] = datetime.now().isoformat()
        if rating_suggestion is not None:
            update_data['ai_grade'] = rating_suggestion
            update_data['grade_generated_at'] = datetime.now().isoformat()
        if feed_back_text is not None:
            update_data['feed_back_text'] = feed_back_text
        if feed_forward_text is not None:
            update_data['feed_forward_text'] = feed_forward_text

        if not update_data:
            print(f"Keine AI-Daten zum Aktualisieren für Submission {submission_id} übergeben.")
            return True, None

        # --- Verwende den Service Client für das Update ---
        response = service_client.table('submission') \
                                .update(update_data) \
                                .eq('id', submission_id) \
                                .execute()
        # --- Ende Verwendung Service Client ---

        if hasattr(response, 'error') and response.error:
            # Selbst mit Service Key können Fehler auftreten (z.B. ungültige Daten)
            error_msg = f"DB Fehler beim Aktualisieren der AI-Ergebnisse (via Service Role) für Submission {submission_id}: {response.error.message}"
            print(error_msg)
            return False, error_msg

        # Erfolg wird angenommen, wenn kein Fehler auftritt
        print(f"AI-Ergebnisse für Submission {submission_id} erfolgreich via Service Role aktualisiert.")
        return True, None

    except Exception as e:
         error_msg = f"Python Fehler beim Aktualisieren der AI-Ergebnisse für Submission {submission_id}: {e}"
         print(f"Exception in update_submission_ai_results: {traceback.format_exc()}")
         return False, error_msg

def get_submission_by_id(submission_id: str) -> tuple[dict | None, str | None]:
    """Holt eine einzelne Einreichung mit allen Details.
    
    Returns:
        tuple: (Submission-Dict, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not submission_id:
        return None, "Submission-ID ist erforderlich."
    
    try:
        response = supabase_client.table('submission') \
            .select('*') \
            .eq('id', submission_id) \
            .single() \
            .execute()
        
        if hasattr(response, 'data') and response.data:
            return response.data, None
        elif hasattr(response, 'error') and response.error:
            return None, f"Fehler beim Abrufen der Submission: {response.error.message}"
        else:
            return None, "Submission nicht gefunden."
    
    except Exception as e:
        error_msg = f"Fehler beim Abrufen der Submission {submission_id}: {e}"
        print(f"Exception in get_submission_by_id: {e}")
        return None, error_msg

def get_submission_for_task(student_id: str, task_id: str) -> tuple[dict | None, str | None]:
    """Holt die Einreichung eines Schülers für eine bestimmte Aufgabe.
    
    Returns:
        tuple: (Submission-Dict, None) bei Erfolg, (None, Fehlermeldung) bei Fehler oder wenn keine Einreichung existiert.
    """
    if not student_id or not task_id:
        return None, "Student-ID und Task-ID sind erforderlich."
    
    try:
        response = supabase_client.table('submission') \
            .select('*') \
            .eq('student_id', student_id) \
            .eq('task_id', task_id) \
            .maybe_single() \
            .execute()
        
        if hasattr(response, 'data') and response.data:
            return response.data, None
        elif hasattr(response, 'error') and response.error:
            return None, f"Fehler beim Abrufen der Submission: {response.error.message}"
        else:
            return None, None  # Keine Einreichung gefunden (kein Fehler)
    
    except Exception as e:
        error_msg = f"Fehler beim Abrufen der Submission für Student {student_id} und Task {task_id}: {e}"
        print(f"Exception in get_submission_for_task: {e}")
        return None, error_msg

# --- Live-Übersicht Funktionen ---

def get_course_students(course_id: str) -> tuple[list | None, str | None]:
    """Holt alle Schüler eines Kurses für die Live-Übersicht.
    
    Returns:
        tuple: (Liste mit student_id, full_name, email), None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not course_id:
        return [], None
    
    try:
        response = supabase_client.table('course_student') \
            .select('student_id, profiles!inner(full_name, email)') \
            .eq('course_id', course_id) \
            .order('profiles(full_name)') \
            .execute()
        
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Schüler für Kurs {course_id}: {response.error.message}"
            print(f"Fehler in get_course_students: {response.error}")
            return None, error_msg
        
        if hasattr(response, 'data'):
            # Transformiere die Daten in flaches Format
            students = []
            for item in response.data:
                if item.get('profiles'):
                    profile = item['profiles']
                    # Verwende E-Mail-Präfix als Fallback für den Namen
                    full_name = profile.get('full_name')
                    if not full_name or full_name == 'None':
                        email = profile.get('email', '')
                        # Extrahiere den Teil vor dem @ als Namen
                        full_name = email.split('@')[0] if '@' in email else email
                    
                    students.append({
                        'student_id': item['student_id'],
                        'full_name': full_name,
                        'email': profile.get('email', '')
                    })
            # Sortiere nach Namen
            students.sort(key=lambda x: x['full_name'].lower())
            return students, None
        else:
            return None, "Unerwartete Antwort beim Abrufen der Schüler."
    
    except Exception as e:
        error_msg = f"Fehler beim Abrufen der Schüler: {e}"
        print(f"Exception in get_course_students: {e}")
        return None, error_msg

def get_section_tasks(section_id: str) -> tuple[list | None, str | None]:
    """Holt alle Aufgaben eines Abschnitts.
    
    Returns:
        tuple: (Liste mit task_id, order_in_section, instruction), None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not section_id:
        return [], None
    
    try:
        response = supabase_client.table('task') \
            .select('id, order_in_section, instruction') \
            .eq('section_id', section_id) \
            .order('order_in_section') \
            .execute()
        
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Aufgaben für Abschnitt {section_id}: {response.error.message}"
            print(f"Fehler in get_section_tasks: {response.error}")
            return None, error_msg
        
        if hasattr(response, 'data'):
            return response.data, None
        else:
            return None, "Unerwartete Antwort beim Abrufen der Aufgaben."
    
    except Exception as e:
        error_msg = f"Fehler beim Abrufen der Aufgaben: {e}"
        print(f"Exception in get_section_tasks: {e}")
        return None, error_msg

def get_submission_status_matrix(course_id: str, unit_id: str) -> tuple[dict | None, str | None]:
    """Holt die komplette Matrix-Ansicht für die Live-Übersicht.
    
    Returns:
        tuple: (Dictionary mit Struktur für Matrix-View, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not course_id or not unit_id:
        return None, "Kurs-ID und Einheiten-ID sind erforderlich."
    
    try:
        # 1. Hole alle Schüler des Kurses
        students, error = get_course_students(course_id)
        if error:
            return None, error
        
        # 2. Hole alle veröffentlichten Abschnitte der Einheit für diesen Kurs
        section_statuses, error = get_section_statuses_for_unit_in_course(unit_id, course_id)
        if error:
            return None, error
        
        published_section_ids = [sid for sid, is_pub in section_statuses.items() if is_pub]
        
        if not published_section_ids:
            return {
                "students": students,
                "sections": [],
                "total_tasks": 0,
                "total_submissions": 0
            }, None
        
        # 3. Hole Abschnitt-Details
        sections_response = supabase_client.table('unit_section') \
            .select('id, title, order_in_unit') \
            .eq('unit_id', unit_id) \
            .in_('id', published_section_ids) \
            .order('order_in_unit') \
            .execute()
        
        if hasattr(sections_response, 'error') and sections_response.error:
            return None, f"Fehler beim Abrufen der Abschnitte: {sections_response.error.message}"
        
        sections = sections_response.data if hasattr(sections_response, 'data') else []
        
        # 4. Hole alle Aufgaben für diese Abschnitte
        all_tasks = []
        section_tasks_map = {}
        
        for section in sections:
            tasks, error = get_section_tasks(section['id'])
            if error:
                print(f"Warnung: Konnte Aufgaben für Abschnitt {section['id']} nicht laden: {error}")
                tasks = []
            
            section_tasks_map[section['id']] = tasks
            all_tasks.extend(tasks)
        
        # 5. Hole alle Submissions für diese Aufgaben und Schüler
        submissions_map = {}
        total_submissions = 0
        
        if all_tasks and students:
            task_ids = [t['id'] for t in all_tasks]
            student_ids = [s['student_id'] for s in students]
            
            submissions_response = supabase_client.table('submission') \
                .select('student_id, task_id, submission_data, ai_feedback, submitted_at') \
                .in_('task_id', task_ids) \
                .in_('student_id', student_ids) \
                .execute()
            
            if hasattr(submissions_response, 'data'):
                for sub in submissions_response.data:
                    key = f"{sub['student_id']}_{sub['task_id']}"
                    submissions_map[key] = {
                        'status': 'submitted',
                        'submitted_at': sub['submitted_at'],
                        'has_ai_feedback': bool(sub.get('ai_feedback')),
                        'submission_data': sub['submission_data']
                    }
                    total_submissions += 1
        
        # 6. Baue die finale Struktur
        result = {
            "students": students,
            "sections": [],
            "total_tasks": len(all_tasks),
            "total_submissions": total_submissions
        }
        
        for section in sections:
            section_data = {
                "section_id": section['id'],
                "title": section['title'],
                "order_in_unit": section['order_in_unit'],
                "tasks": section_tasks_map.get(section['id'], []),
                "submissions": {}
            }
            
            # Füge Submission-Status für jeden Schüler und jede Aufgabe hinzu
            for student in students:
                section_data["submissions"][student['student_id']] = {}
                for task in section_tasks_map.get(section['id'], []):
                    key = f"{student['student_id']}_{task['id']}"
                    if key in submissions_map:
                        section_data["submissions"][student['student_id']][task['id']] = submissions_map[key]
                    else:
                        section_data["submissions"][student['student_id']][task['id']] = {
                            'status': 'not_started',
                            'submitted_at': None,
                            'has_ai_feedback': False,
                            'submission_data': None
                        }
            
            result["sections"].append(section_data)
        
        return result, None
    
    except Exception as e:
        error_msg = f"Fehler beim Erstellen der Submission-Matrix: {e}"
        print(f"Exception in get_submission_status_matrix: {e}")
        return None, error_msg

# --- Teacher Override Funktionen ---

def update_submission_teacher_override(submission_id: str, teacher_feedback: str | None, teacher_grade: str | None) -> tuple[bool, str | None]:
    """Aktualisiert eine Einreichung mit Lehrer-Feedback und/oder Bewertung.
    Verwendet den Service Role Client, um RLS zu umgehen.
    
    Args:
        submission_id: ID der Einreichung
        teacher_feedback: Lehrer-Feedback (None = nicht ändern)
        teacher_grade: Lehrer-Bewertung (None = nicht ändern)
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not submission_id:
        return False, "Submission-ID ist erforderlich."
    
    # Hole den Service Client
    service_client = get_supabase_service_client()
    if service_client is None:
        return False, "Supabase Service Client konnte nicht initialisiert werden."
    
    try:
        update_data = {}
        
        # Füge nur die Felder hinzu, die aktualisiert werden sollen
        if teacher_feedback is not None:
            update_data['teacher_override_feedback'] = teacher_feedback
        
        if teacher_grade is not None:
            update_data['teacher_override_grade'] = teacher_grade
        
        if not update_data:
            return True, None  # Nichts zu aktualisieren
        
        # Update durchführen
        response = service_client.table('submission') \
            .update(update_data) \
            .eq('id', submission_id) \
            .execute()
        
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Aktualisieren der Lehrer-Bewertung: {response.error.message}"
            print(f"Fehler in update_submission_teacher_override: {response.error}")
            return False, error_msg
        
        print(f"Lehrer-Override für Submission {submission_id} erfolgreich aktualisiert.")
        return True, None
    
    except Exception as e:
        error_msg = f"Fehler beim Aktualisieren der Lehrer-Bewertung: {e}"
        print(f"Exception in update_submission_teacher_override: {e}")
        return False, error_msg

def get_submissions_for_course_and_unit(course_id: str, unit_id: str) -> tuple[list | None, str | None]:
    """Holt alle Einreichungen für eine Lerneinheit in einem Kurs mit vollständigen Details.
    
    Returns:
        tuple: (Liste von Submissions mit Student/Task-Info, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not course_id or not unit_id:
        return None, "Kurs-ID und Einheiten-ID sind erforderlich."
    
    try:
        # 1. Hole alle veröffentlichten Abschnitte
        section_statuses, error = get_section_statuses_for_unit_in_course(unit_id, course_id)
        if error:
            return None, error
        
        published_section_ids = [sid for sid, is_pub in section_statuses.items() if is_pub]
        if not published_section_ids:
            return [], None  # Keine veröffentlichten Abschnitte
        
        # 2. Hole alle Aufgaben in diesen Abschnitten
        tasks_response = supabase_client.table('task') \
            .select('id, section_id, unit_section!inner(title)') \
            .in_('section_id', published_section_ids) \
            .execute()
        
        if hasattr(tasks_response, 'error') and tasks_response.error:
            return None, f"Fehler beim Abrufen der Aufgaben: {tasks_response.error.message}"
        
        task_ids = [t['id'] for t in tasks_response.data] if hasattr(tasks_response, 'data') else []
        if not task_ids:
            return [], None  # Keine Aufgaben
        
        # 3. Hole alle Submissions für diese Aufgaben mit Student-Info
        # Verwende einen JOIN über student_id -> profiles.id
        submissions_response = supabase_client.table('submission') \
            .select('''
                *,
                task!inner(section_id)
            ''') \
            .in_('task_id', task_ids) \
            .order('submitted_at', desc=True) \
            .execute()
        
        if hasattr(submissions_response, 'error') and submissions_response.error:
            return None, f"Fehler beim Abrufen der Einreichungen: {submissions_response.error.message}"
        
        if hasattr(submissions_response, 'data'):
            # Hole alle eindeutigen Student-IDs
            student_ids = list(set(sub['student_id'] for sub in submissions_response.data))
            
            # Hole Student-Profile separat
            student_profiles = {}
            if student_ids:
                profiles_response = supabase_client.table('profiles') \
                    .select('id, full_name, email') \
                    .in_('id', student_ids) \
                    .execute()
                
                if hasattr(profiles_response, 'data'):
                    for profile in profiles_response.data:
                        # Name fallback
                        name = profile.get('full_name')
                        if not name or name == 'None':
                            email = profile.get('email', '')
                            name = email.split('@')[0] if '@' in email else email
                        
                        student_profiles[profile['id']] = {
                            'full_name': name,
                            'email': profile.get('email', '')
                        }
            
            # Bereichere die Daten mit Abschnittsinformationen
            task_section_map = {t['id']: t for t in tasks_response.data}
            
            enriched_submissions = []
            for sub in submissions_response.data:
                # Hole Student-Info aus dem vorgeladenen Dict
                student_info = student_profiles.get(sub['student_id'], {
                    'full_name': 'Unbekannter Schüler',
                    'email': ''
                })
                
                # Füge Abschnittsinfo hinzu
                task_info = task_section_map.get(sub['task_id'], {})
                
                enriched_submissions.append({
                    'id': sub['id'],
                    'student_id': sub['student_id'],
                    'student_name': student_info['full_name'],
                    'student_email': student_info['email'],
                    'task_id': sub['task_id'],
                    'task_title': 'Aufgabe',  # Title wurde aus dem Schema entfernt
                    'section_title': task_info.get('unit_section', {}).get('title', 'Unbekannter Abschnitt'),
                    'submission_data': sub['submission_data'],
                    'submitted_at': sub['submitted_at'],
                    'ai_feedback': sub.get('ai_feedback'),
                    'ai_grade': sub.get('ai_grade'),
                    'ai_criteria_analysis': sub.get('ai_criteria_analysis'),
                    'teacher_override_feedback': sub.get('teacher_override_feedback'),
                    'teacher_override_grade': sub.get('teacher_override_grade'),
                    'has_teacher_override': bool(sub.get('teacher_override_feedback') or sub.get('teacher_override_grade'))
                })
            
            return enriched_submissions, None
        else:
            return [], None
    
    except Exception as e:
        error_msg = f"Fehler beim Abrufen der Einreichungen: {e}"
        print(f"Exception in get_submissions_for_course_and_unit: {e}")
        return None, error_msg

# --- Lerneinheiten-Funktionen ---

def get_learning_units_by_creator(creator_id: str) -> tuple[list | None, str | None]:
    """Holt alle Lerneinheiten eines Lehrers.
    
    Returns:
        tuple: (Liste der Lerneinheiten, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not creator_id: 
        return [], None
    try:
        response = supabase_client.table('learning_unit') \
                                .select('id, title, created_at') \
                                .eq('creator_id', creator_id) \
                                .order('created_at', desc=True) \
                                .execute()
        
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Lerneinheiten: {response.error.message}"
            print(f"Fehler in get_learning_units_by_creator: {response.error}")
            return None, error_msg
        
        if hasattr(response, 'data'):
            return response.data, None
        else:
            return None, "Unerwartete Antwort beim Abrufen der Lerneinheiten."
    except Exception as e:
        error_msg = f"Fehler beim Abrufen der Lerneinheiten: {e}"
        print(f"Exception in get_learning_units_by_creator: {e}")
        return None, error_msg

def create_learning_unit(title: str, creator_id: str) -> tuple[dict | None, str | None]:
    """Erstellt eine neue Lerneinheit.
    
    Returns:
        tuple: (Neue Lerneinheit, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not all([title, creator_id]): 
        return None, "Titel und Creator-ID sind erforderlich."
    try:
        response = supabase_client.table('learning_unit') \
                                .insert({'title': title, 'creator_id': creator_id}) \
                                .execute()
        if hasattr(response, 'data') and response.data:
            return response.data[0], None
        elif hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Erstellen der Lerneinheit: {response.error.message}"
            print(f"Fehler in create_learning_unit: {response.error}")
            return None, error_msg
        else:
            return None, "Unerwartete Antwort beim Erstellen der Lerneinheit."
    except Exception as e:
        error_msg = f"Fehler beim Erstellen der Lerneinheit: {e}"
        print(f"Exception in create_learning_unit: {e}")
        return None, error_msg

def update_learning_unit(unit_id: str, title: str) -> tuple[bool, str | None]:
    """Aktualisiert den Titel einer Lerneinheit.
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not all([unit_id, title]):
        return False, "Unit-ID und Titel sind erforderlich."
    try:
        response = supabase_client.table('learning_unit') \
                                .update({'title': title}) \
                                .eq('id', unit_id) \
                                .execute()
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Aktualisieren der Lerneinheit: {response.error.message}"
            print(f"Fehler in update_learning_unit: {response.error}")
            return False, error_msg
        return True, None
    except Exception as e:
        error_msg = f"Fehler beim Aktualisieren der Lerneinheit: {e}"
        print(f"Exception in update_learning_unit: {e}")
        return False, error_msg

def delete_learning_unit(unit_id: str) -> tuple[bool, str | None]:
    """Löscht eine Lerneinheit.
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not unit_id:
        return False, "Unit-ID ist erforderlich."
    try:
        response = supabase_client.table('learning_unit') \
                                .delete() \
                                .eq('id', unit_id) \
                                .execute()
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Löschen der Lerneinheit: {response.error.message}"
            print(f"Fehler in delete_learning_unit: {response.error}")
            return False, error_msg
        return True, None
    except Exception as e:
        error_msg = f"Fehler beim Löschen der Lerneinheit: {e}"
        print(f"Exception in delete_learning_unit: {e}")
        return False, error_msg

def get_learning_unit_by_id(unit_id: str) -> tuple[dict | None, str | None]:
    """Holt eine einzelne Lerneinheit.
    
    Returns:
        tuple: (Lerneinheit, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not unit_id:
        return None, "Unit-ID ist erforderlich."
    try:
        response = supabase_client.table('learning_unit') \
                                .select('*') \
                                .eq('id', unit_id) \
                                .single() \
                                .execute()
        
        if hasattr(response, 'data') and response.data:
            return response.data, None
        elif hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Lerneinheit: {response.error.message}"
            print(f"Fehler in get_learning_unit_by_id: {response.error}")
            return None, error_msg
        else:
            return None, "Lerneinheit nicht gefunden."
    except Exception as e:
        error_msg = f"Fehler beim Abrufen der Lerneinheit: {e}"
        print(f"Exception in get_learning_unit_by_id: {e}")
        return None, error_msg

# --- Abschnitt-Funktionen ---

def create_section(unit_id: str, title: str, order: int) -> tuple[dict | None, str | None]:
    """Erstellt einen neuen Abschnitt in einer Lerneinheit.
    
    Returns:
        tuple: (Neuer Abschnitt, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not all([unit_id, isinstance(order, int)]): 
        return None, "Unit-ID und Order sind erforderlich."
    try:
        response = supabase_client.table('unit_section') \
                                .insert({
                                    'unit_id': unit_id, 
                                    'title': title if title else f"Abschnitt {order}", 
                                    'order_in_unit': order, 
                                    'materials': []
                                }) \
                                .execute()
        if hasattr(response, 'data') and response.data:
            return response.data[0], None
        elif hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Erstellen des Abschnitts: {response.error.message}"
            print(f"Fehler in create_section: {response.error}")
            return None, error_msg
        else:
            return None, "Unerwartete Antwort beim Erstellen des Abschnitts."
    except Exception as e:
        error_msg = f"Fehler beim Erstellen des Abschnitts: {e}"
        print(f"Exception in create_section: {e}")
        return None, error_msg

def update_section_materials(section_id: str, materials: list) -> tuple[bool, str | None]:
    """Aktualisiert die Materialien eines Abschnitts.
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not section_id:
        return False, "Section-ID ist erforderlich."
    try:
        response = supabase_client.table('unit_section') \
                                .update({'materials': materials}) \
                                .eq('id', section_id) \
                                .execute()
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Aktualisieren der Materialien: {response.error.message}"
            print(f"Fehler in update_section_materials: {response.error}")
            return False, error_msg
        return True, None
    except Exception as e:
        error_msg = f"Fehler beim Aktualisieren der Materialien: {e}"
        print(f"Exception in update_section_materials: {e}")
        return False, error_msg

# --- Aufgaben-Funktionen ---

def get_tasks_for_section(section_id: str) -> tuple[list | None, str | None]:
    """Holt alle Aufgaben eines Abschnitts.
    
    Returns:
        tuple: (Liste der Aufgaben, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not section_id: 
        return [], None
    try:
        response = supabase_client.table('task') \
                                .select('id, instruction, task_type, order_in_section, assessment_criteria, solution_hints, is_mastery, created_at') \
                                .eq('section_id', section_id) \
                                .order('order_in_section', desc=False) \
                                .order('created_at', desc=False) \
                                .execute()
        
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen der Aufgaben: {response.error.message}"
            print(f"Fehler in get_tasks_for_section: {response.error}")
            return None, error_msg
        
        if hasattr(response, 'data'):
            return response.data, None
        else:
            return None, "Unerwartete Antwort beim Abrufen der Aufgaben."
    except Exception as e:
        error_msg = f"Fehler beim Abrufen der Aufgaben: {e}"
        print(f"Exception in get_tasks_for_section: {e}")
        return None, error_msg

def create_task(section_id: str, instruction: str, task_type: str, assessment_criteria: list[str] | None = None, 
                solution_hints: str | None = None, is_mastery: bool = False, max_attempts: int = 1) -> tuple[dict | None, str | None]:
    """Erstellt eine neue Aufgabe in einem Abschnitt.
    
    Args:
        section_id: ID des Abschnitts
        instruction: Aufgabenstellung
        task_type: Art der Aufgabe (text/file/code)
        assessment_criteria: Liste von Bewertungskriterien (max. 5)
        solution_hints: Lösungshinweise oder Musterlösung
        is_mastery: Ob die Aufgabe eine Wissensfestiger-Aufgabe ist
        max_attempts: Maximale Anzahl erlaubter Einreichungsversuche (Standard: 1)
    
    Returns:
        tuple: (Neue Aufgabe, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not all([section_id, instruction, task_type]): 
        return None, "Section-ID, Instruction und Task-Type sind erforderlich."
    
    # Validierung der assessment_criteria
    if assessment_criteria and len(assessment_criteria) > 5:
        return None, "Maximal 5 Bewertungskriterien erlaubt."
    
    try:
        # Bestimme die nächste order_in_section
        tasks, error = get_tasks_for_section(section_id)
        if error:
            return None, error
        
        next_order = 0
        if tasks:
            max_order = max(task.get('order_in_section', -1) for task in tasks if task.get('order_in_section') is not None)
            next_order = max_order + 1
        
        insert_data = {
            'section_id': section_id, 
            'instruction': instruction, 
            'task_type': task_type, 
            'order_in_section': next_order,
            'assessment_criteria': assessment_criteria or [],
            'solution_hints': solution_hints,
            'is_mastery': is_mastery,
            'max_attempts': max_attempts
        }
        
        response = supabase_client.table('task') \
                                .insert(insert_data) \
                                .execute()
        
        if hasattr(response, 'data') and response.data:
            return response.data[0], None
        elif hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Erstellen der Aufgabe: {response.error.message}"
            print(f"Fehler in create_task: {response.error}")
            return None, error_msg
        else:
            return None, "Unerwartete Antwort beim Erstellen der Aufgabe."
    except Exception as e:
        error_msg = f"Fehler beim Erstellen der Aufgabe: {e}"
        print(f"Exception in create_task: {e}")
        return None, error_msg

def update_task(task_id: str, instruction: str, assessment_criteria: list[str] | None = None, 
                solution_hints: str | None = None, is_mastery: bool = False, max_attempts: int | None = None) -> tuple[bool, str | None]:
    """Aktualisiert eine Aufgabe.
    
    Args:
        task_id: ID der Aufgabe
        instruction: Neue Aufgabenstellung
        assessment_criteria: Liste von Bewertungskriterien (max. 5)
        solution_hints: Lösungshinweise oder Musterlösung
        is_mastery: Ob die Aufgabe eine Wissensfestiger-Aufgabe ist
        max_attempts: Maximale Anzahl erlaubter Einreichungsversuche (None = nicht ändern)
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not task_id:
        return False, "Task-ID ist erforderlich."
    
    # Validierung der assessment_criteria
    if assessment_criteria and len(assessment_criteria) > 5:
        return False, "Maximal 5 Bewertungskriterien erlaubt."
    
    try:
        update_data = {
            'instruction': instruction,
            'assessment_criteria': assessment_criteria or [],
            'solution_hints': solution_hints,
            'is_mastery': is_mastery
        }
        
        # Füge max_attempts nur hinzu wenn explizit gesetzt
        if max_attempts is not None:
            update_data['max_attempts'] = max_attempts
        
        response = supabase_client.table('task') \
                                .update(update_data) \
                                .eq('id', task_id) \
                                .execute()
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Aktualisieren der Aufgabe: {response.error.message}"
            print(f"Fehler in update_task: {response.error}")
            return False, error_msg
        return True, None
    except Exception as e:
        error_msg = f"Fehler beim Aktualisieren der Aufgabe: {e}"
        print(f"Exception in update_task: {e}")
        return False, error_msg

def delete_task(task_id: str) -> tuple[bool, str | None]:
    """Löscht eine Aufgabe.
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not task_id:
        return False, "Task-ID ist erforderlich."
    try:
        response = supabase_client.table('task') \
                                .delete() \
                                .eq('id', task_id) \
                                .execute()
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Löschen der Aufgabe: {response.error.message}"
            print(f"Fehler in delete_task: {response.error}")
            return False, error_msg
        return True, None
    except Exception as e:
        error_msg = f"Fehler beim Löschen der Aufgabe: {e}"
        print(f"Exception in delete_task: {e}")
        return False, error_msg

def move_task_up(task_id: str, section_id: str) -> tuple[bool, str | None]:
    """Verschiebt eine Aufgabe um eine Position nach oben.
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not task_id or not section_id:
        return False, "Task-ID und Section-ID sind erforderlich."
    
    try:
        # Hole alle Aufgaben des Abschnitts
        tasks, error = get_tasks_for_section(section_id)
        if error:
            return False, error
        
        # Finde die aktuelle Aufgabe
        current_task = None
        current_index = -1
        for i, task in enumerate(tasks):
            if task['id'] == task_id:
                current_task = task
                current_index = i
                break
        
        if current_index <= 0:
            return False, "Aufgabe kann nicht weiter nach oben verschoben werden."
        
        # Tausche mit der vorherigen Aufgabe
        prev_task = tasks[current_index - 1]
        
        # Update beide Aufgaben
        response1 = supabase_client.table('task') \
                                 .update({'order_in_section': prev_task['order_in_section']}) \
                                 .eq('id', task_id) \
                                 .execute()
        
        response2 = supabase_client.table('task') \
                                 .update({'order_in_section': current_task['order_in_section']}) \
                                 .eq('id', prev_task['id']) \
                                 .execute()
        
        if (hasattr(response1, 'error') and response1.error) or \
           (hasattr(response2, 'error') and response2.error):
            return False, "Fehler beim Verschieben der Aufgabe."
        
        return True, None
        
    except Exception as e:
        error_msg = f"Fehler beim Verschieben der Aufgabe: {e}"
        print(f"Exception in move_task_up: {e}")
        return False, error_msg

def move_task_down(task_id: str, section_id: str) -> tuple[bool, str | None]:
    """Verschiebt eine Aufgabe um eine Position nach unten.
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not task_id or not section_id:
        return False, "Task-ID und Section-ID sind erforderlich."
    
    try:
        # Hole alle Aufgaben des Abschnitts
        tasks, error = get_tasks_for_section(section_id)
        if error:
            return False, error
        
        # Finde die aktuelle Aufgabe
        current_task = None
        current_index = -1
        for i, task in enumerate(tasks):
            if task['id'] == task_id:
                current_task = task
                current_index = i
                break
        
        if current_index == -1 or current_index >= len(tasks) - 1:
            return False, "Aufgabe kann nicht weiter nach unten verschoben werden."
        
        # Tausche mit der nächsten Aufgabe
        next_task = tasks[current_index + 1]
        
        # Update beide Aufgaben
        response1 = supabase_client.table('task') \
                                 .update({'order_in_section': next_task['order_in_section']}) \
                                 .eq('id', task_id) \
                                 .execute()
        
        response2 = supabase_client.table('task') \
                                 .update({'order_in_section': current_task['order_in_section']}) \
                                 .eq('id', next_task['id']) \
                                 .execute()
        
        if (hasattr(response1, 'error') and response1.error) or \
           (hasattr(response2, 'error') and response2.error):
            return False, "Fehler beim Verschieben der Aufgabe."
        
        return True, None
        
    except Exception as e:
        error_msg = f"Fehler beim Verschieben der Aufgabe: {e}"
        print(f"Exception in move_task_down: {e}")
        return False, error_msg

def update_course(course_id: str, name: str) -> tuple[bool, str | None]:
    """Aktualisiert den Namen eines Kurses.
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not course_id or not name or not name.strip():
        return False, "Kurs-ID und Name sind erforderlich."
    
    try:
        response = supabase_client.table('course') \
                                .update({'name': name.strip()}) \
                                .eq('id', course_id) \
                                .execute()
        
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Aktualisieren des Kurses: {response.error.message}"
            print(f"Fehler in update_course: {response.error}")
            return False, error_msg
        
        return True, None
    
    except Exception as e:
        error_msg = f"Fehler beim Aktualisieren des Kurses: {e}"
        print(f"Exception in update_course: {e}")
        return False, error_msg


def delete_course(course_id: str) -> tuple[bool, str | None]:
    """Löscht einen Kurs. Durch CASCADE werden auch alle Zuweisungen gelöscht.
    
    Returns:
        tuple: (True, None) bei Erfolg, (False, Fehlermeldung) bei Fehler.
    """
    if not course_id:
        return False, "Kurs-ID ist erforderlich."
    
    try:
        response = supabase_client.table('course') \
                                .delete() \
                                .eq('id', course_id) \
                                .execute()
        
        if hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Löschen des Kurses: {response.error.message}"
            print(f"Fehler in delete_course: {response.error}")
            return False, error_msg
        
        return True, None
    
    except Exception as e:
        error_msg = f"Fehler beim Löschen des Kurses: {e}"
        print(f"Exception in delete_course: {e}")
        return False, error_msg


def is_teacher_authorized_for_course(teacher_id: str, course_id: str) -> tuple[bool, str | None]:
    """Prüft, ob ein Lehrer berechtigt ist, einen Kurs zu verwalten.
    Ein Lehrer ist berechtigt wenn er:
    1. Der Ersteller (creator_id) des Kurses ist ODER
    2. In der course_teacher Tabelle für diesen Kurs eingetragen ist
    
    Returns:
        tuple: (True, None) wenn berechtigt, (False, Grund) wenn nicht berechtigt
    """
    if not teacher_id or not course_id:
        return False, "Lehrer-ID und Kurs-ID sind erforderlich."
    
    try:
        # Hole Kursdetails
        course, error = get_course_by_id(course_id)
        if error or not course:
            return False, "Kurs nicht gefunden."
        
        # Prüfe ob Lehrer der Ersteller ist
        if course.get('creator_id') == teacher_id:
            return True, None
        
        # Prüfe ob Lehrer in course_teacher Tabelle ist
        response = supabase_client.table('course_teacher') \
                                .select('teacher_id') \
                                .eq('course_id', course_id) \
                                .eq('teacher_id', teacher_id) \
                                .execute()
        
        if hasattr(response, 'data') and response.data:
            return True, None
        
        return False, "Sie sind nicht berechtigt, diesen Kurs zu verwalten."
    
    except Exception as e:
        error_msg = f"Fehler bei der Berechtigungsprüfung: {e}"
        print(f"Exception in is_teacher_authorized_for_course: {e}")
        return False, error_msg


def get_course_by_id(course_id: str) -> tuple[dict | None, str | None]:
    """Holt einen einzelnen Kurs.
    
    Returns:
        tuple: (Kurs, None) bei Erfolg, (None, Fehlermeldung) bei Fehler.
    """
    if not course_id:
        return None, "Course-ID ist erforderlich."
    try:
        response = supabase_client.table('course') \
                                .select('*') \
                                .eq('id', course_id) \
                                .single() \
                                .execute()
        
        if hasattr(response, 'data') and response.data:
            return response.data, None
        elif hasattr(response, 'error') and response.error:
            error_msg = f"Fehler beim Abrufen des Kurses: {response.error.message}"
            print(f"Fehler in get_course_by_id: {response.error}")
            return None, error_msg
        else:
            return None, "Kurs nicht gefunden."
    except Exception as e:
        error_msg = f"Fehler beim Abrufen des Kurses: {e}"
        print(f"Exception in get_course_by_id: {e}")
        return None, error_msg

# --- Wissensfestiger (Mastery Learning) Funktionen ---

from datetime import date, datetime, timezone
import random
from typing import Dict, List, Optional, Tuple

# Mastery imports moved to function level to avoid circular dependencies
# This prevents DSPy/OpenAI version conflicts when importing this module


def get_mastery_tasks_for_course(course_id: str) -> tuple[list | None, str | None]:
    """
    Holt alle Mastery-Aufgaben (is_mastery=True) für einen bestimmten Kurs.
    Berücksichtigt nur Aufgaben aus freigegebenen Abschnitten.
    """
    try:
        units_response = (
            supabase_client
            .table("course_learning_unit_assignment")
            .select("unit_id")
            .eq("course_id", course_id)
            .execute()
        )
        
        if hasattr(units_response, "error") and units_response.error:
            return None, f"Fehler beim Abrufen der Kurs-Units: {units_response.error.message}"
        if not hasattr(units_response, "data") or not units_response.data:
            return [], None
        
        unit_ids = [u["unit_id"] for u in units_response.data]
        
        sections_response = (
            supabase_client
            .table("unit_section")
            .select("id")
            .in_("unit_id", unit_ids)
            .execute()
        )
        
        if hasattr(sections_response, "error") and sections_response.error:
            return None, f"Fehler beim Abrufen der Sections: {sections_response.error.message}"
        if not hasattr(sections_response, "data") or not sections_response.data:
            return [], None
        
        section_ids = [s["id"] for s in sections_response.data]
        
        # NEU: Filtere auf freigegebene Sections
        published_sections_response = (
            supabase_client
            .table("course_unit_section_status")
            .select("section_id")
            .eq("course_id", course_id)
            .eq("is_published", True)
            .execute()
        )
        
        if hasattr(published_sections_response, "error") and published_sections_response.error:
            return None, f"Fehler beim Abrufen der freigegebenen Sections: {published_sections_response.error.message}"
        
        published_section_ids = []
        if hasattr(published_sections_response, "data") and published_sections_response.data:
            published_section_ids = [s["section_id"] for s in published_sections_response.data]
        
        # Schneide die Listen: nur Sections die existieren UND freigegeben sind
        section_ids = list(set(section_ids) & set(published_section_ids))
        
        if not section_ids:
            return [], None  # Keine freigegebenen Sections
        
        tasks_response = (
            supabase_client
            .table("task")
            .select("*, unit_section!inner(title, unit_id)")
            .eq("is_mastery", True)
            .in_("section_id", section_ids)
            .execute()
        )
        
        if hasattr(tasks_response, "error") and tasks_response.error:
            return None, f"Fehler beim Abrufen der Mastery-Aufgaben: {tasks_response.error.message}"
        
        return tasks_response.data if hasattr(tasks_response, "data") else [], None
    except Exception as e:
        return None, f"Fehler beim Abrufen der Mastery-Aufgaben: {e}"



def get_next_due_mastery_task(student_id: str, course_id: str) -> tuple[dict | None, str | None]:
    """
    Holt die nächste fällige Wissensfestiger-Aufgabe für einen Schüler in einem Kurs.
    """
    try:
        mastery_tasks, error = get_mastery_tasks_for_course(course_id)
        if error or not mastery_tasks:
            return None, error or "Keine Wissensfestiger-Aufgaben in diesem Kurs gefunden."

        task_ids = [task["id"] for task in mastery_tasks]

        progress_response = (
            supabase_client
            .table("student_mastery_progress")
            .select("*")
            .eq("student_id", student_id)
            .in_("task_id", task_ids)
            .execute()
        )

        if hasattr(progress_response, "error") and progress_response.error:
            return None, f"Fehler beim Abrufen des Lernfortschritts: {progress_response.error.message}"

        progress_by_task = (
            {p["task_id"]: p for p in progress_response.data}
            if hasattr(progress_response, "data")
            else {}
        )

        today = date.today()
        due_tasks = []

        for task in mastery_tasks:
            progress = progress_by_task.get(task["id"])
            if not progress:
                # Neue, noch nie bearbeitete Aufgabe -> immer fällig
                due_tasks.append(task)
            else:
                due_date_str = progress.get("next_due_date")
                if due_date_str:
                    try:
                        # String zu Datum konvertieren (nur Datumsteil nutzen)
                        due_date = datetime.fromisoformat(due_date_str).date()
                        if due_date <= today:
                            due_tasks.append(task)
                    except (ValueError, TypeError):
                        # Ungültiges Datum -> Aufgabe als fällig betrachten
                        print(
                            f"Warnung: Ungültiges 'next_due_date'-Format "
                            f"für Task {task['id']}: {due_date_str}"
                        )
                        due_tasks.append(task)

        if not due_tasks:
            return None, "Keine Aufgaben fällig heute. Komm morgen wieder!"

        # Zufällige fällige Aufgabe auswählen
        selected_task = random.choice(due_tasks)

        # Lernfortschritt hinzufügen, falls vorhanden
        selected_task["mastery_progress"] = progress_by_task.get(selected_task["id"])

        return selected_task, None

    except Exception as e:
        print(f"Exception in get_next_due_mastery_task: {traceback.format_exc()}")
        return None, f"Fehler beim Abrufen der nächsten Aufgabe: {e}"




def save_mastery_submission(student_id: str, task_id: str, answer: str, assessment: dict) -> tuple[dict | None, str | None]:
    """
    Speichert die Antwort und die KI-Bewertung eines Schülers in der mastery_submission Tabelle.
    """
    try:
        q_vec = assessment.get('q_vec', {})
        insert_data = {
            'student_id': student_id,
            'task_id': task_id,
            'answer_text': answer,
            'korrektheit': q_vec.get('korrektheit'),
            'vollstaendigkeit': q_vec.get('vollstaendigkeit'),
            'praegnanz': q_vec.get('praegnanz'),
            'reasoning': assessment.get('reasoning')
        }
        
        response = supabase_client.table('mastery_submission').insert(insert_data).execute()

        if hasattr(response, 'error') and response.error:
            return None, f"Fehler beim Speichern der Antwort: {response.error.message}"
            
        return response.data[0] if response.data else None, None

    except Exception as e:
        return None, f"Unerwarteter Fehler beim Speichern der Antwort: {e}"


# ENTFERNT: Alte update_mastery_progress Funktion - verwende stattdessen _update_mastery_progress


def submit_mastery_answer(student_id: str, task_id: str, answer: str) -> tuple[dict | None, str | None]:
    """
    Verarbeitet eine Wissensfestiger-Antwort: KI-Bewertung & Feedback, Speicherung, Fortschritts-Update.
    """
    from ai.feedback import CombinedMasteryFeedbackModule
    try:
        # 1. Hole Aufgabendetails für die KI
        task_details, error = get_task_details(task_id)
        if error or not task_details:
            return None, error or f"Aufgabe nicht gefunden: {task_id}"

        # 2. Lade Submission-Historie (letzter Versuch)
        submission_history_str = "Dies ist der erste Versuch für diese Aufgabe."
        history, error = get_submission_history(student_id, task_id)
        if error:
            print(f"WARNUNG: Konnte Submission-Historie nicht laden: {error}")
        elif history:
            last_submission = history[-1]
            solution_text = last_submission.get("submission_data", {}).get("text", "(Kein Text)")
            submission_history_str = f"---\n{solution_text}\n---"

        # 3. Generiere kombinierte KI-Bewertung und pädagogisches Feedback
        ai_module = CombinedMasteryFeedbackModule()
        ai_result = ai_module(
            task_details=task_details,
            student_answer=answer,
            submission_history=submission_history_str
        )
        
        q_vec = ai_result.get("q_vec")
        if not q_vec:
            return None, "Fehler bei der KI-Bewertung, kein q_vec erhalten."

        # 4. Speichere die Einreichung mit allen KI-Ergebnissen via Service Client
        service_client = get_supabase_service_client()
        if not service_client:
            return None, "Service Client nicht verfügbar."

        # 4a. Zähle vorhandene Einreichungen für diese Aufgabe
        count_response = (
            service_client
            .table("submission")
            .select("id")
            .eq("student_id", student_id)
            .eq("task_id", task_id)
            .execute()
        )
        
        if hasattr(count_response, "error") and count_response.error:
            return None, f"Fehler beim Zählen der Einreichungen: {count_response.error.message}"
        
        current_attempts = len(count_response.data) if count_response.data else 0
        attempt_number = current_attempts + 1

        submission_data = {
            "student_id": student_id,
            "task_id": task_id,
            "submission_data": {"text": answer},
            "ai_criteria_analysis": q_vec,
            "feed_back_text": ai_result.get("feed_back_text"),
            "feed_forward_text": ai_result.get("feed_forward_text"),
            "ai_feedback": f"{ai_result.get('feed_back_text')}\n\n{ai_result.get('feed_forward_text')}",
            "submitted_at": datetime.now(timezone.utc).isoformat(),
            "attempt_number": attempt_number
        }
        
        insert_response = (
            service_client
            .table("submission")
            .insert(submission_data)
            .execute()
        )
        if hasattr(insert_response, "error") and insert_response.error:
            print(f"WARNUNG: Konnte Wissensfestiger-Antwort nicht speichern: {insert_response.error}")

        # 5. Aktualisiere den Lernfortschritt (ebenfalls mit Service Client)
        success, error = _update_mastery_progress(student_id, task_id, q_vec, service_client)
        if not success:
            print(f"FEHLER: Konnte Lernfortschritt nicht aktualisieren: {error}")
        
        # 6. Gib das vollständige KI-Ergebnis an die UI zurück
        return ai_result, None

    except Exception as e:
        print(f"Traceback in submit_mastery_answer: {traceback.format_exc()}")
        return None, f"Fehler bei der Verarbeitung der Antwort: {e}"



def get_mastery_stats_for_student(student_id: str, course_id: str) -> tuple[dict | None, str | None]:
    """
    Holt Statistiken zum Wissensfestiger-Fortschritt eines Schülers für einen Kurs.
    """
    try:
        mastery_tasks, error = get_mastery_tasks_for_course(course_id)
        if error:
            return None, error
        
        if not mastery_tasks:
            return {
                "total_tasks": 0,
                "mastered": 0,
                "learning": 0,
                "not_started": 0,
                "avg_stability": 0
            }, None

        task_ids = [task["id"] for task in mastery_tasks]
        
        progress_response = (
            supabase_client
            .table("student_mastery_progress")
            .select("stability, difficulty, task_id, last_reviewed_at, next_due_date")
            .eq("student_id", student_id)
            .in_("task_id", task_ids)
            .execute()
        )
            
        if hasattr(progress_response, "error") and progress_response.error:
            return None, f"Fehler beim Abrufen des Fortschritts: {progress_response.error.message}"
        
        progress_data = progress_response.data if hasattr(progress_response, "data") else []
        
        stats = {
            "total_tasks": len(mastery_tasks),
            "mastered": 0,
            "learning": 0,
            "not_started": 0,
            "avg_stability": 0
        }
        
        total_stability = 0
        tasks_with_progress = 0
        
        progress_by_task = {p["task_id"]: p for p in progress_data} if progress_data else {}

        for task_id in task_ids:
            progress = progress_by_task.get(task_id)
            if not progress:
                stats["not_started"] += 1
            else:
                # Ohne state-Feld: Nutze stability als Indikator
                stability = progress.get("stability", 0)
                if stability > 21:  # Hohe Stabilität = gemeistert
                    stats["mastered"] += 1
                elif stability > 0:  # Niedrige Stabilität = am lernen
                    stats["learning"] += 1
                else:
                    stats["not_started"] += 1
                
                if stability > 0:
                    total_stability += stability
                    tasks_with_progress += 1
        
        if tasks_with_progress > 0:
            stats["avg_stability"] = total_stability / tasks_with_progress
            
        return stats, None

    except Exception as e:
        print(f"Exception in get_mastery_stats_for_student: {traceback.format_exc()}")
        return None, f"Fehler beim Abrufen der Statistiken: {e}"


# --- Interne Hilfsfunktionen für Mastery --- 

def _update_mastery_progress(student_id: str, task_id: str, q_vec: dict, service_client) -> tuple[bool, str | None]:
    """
    Interne Funktion zum Aktualisieren des Lernfortschritts.
    Wird von `submit_mastery_answer` aufgerufen und nutzt den übergebenen Service Client.
    """
    # Lazy imports to avoid circular dependencies
    from utils.mastery_algorithm import calculate_next_review_state
    
    if not service_client:
        return False, "Service Client nicht verfügbar."

    try:
        # 1. Hole aktuellen Fortschritt
        progress_response = (
            service_client
            .table("student_mastery_progress")
            .select("stability, difficulty, last_reviewed_at, next_due_date")
            .eq("student_id", student_id)
            .eq("task_id", task_id)
            .maybe_single()
            .execute()
        )
        
        if hasattr(progress_response, "error") and progress_response.error:
            return False, f"Fehler beim Abrufen des Fortschritts: {progress_response.error.message}"
        
        current_progress = progress_response.data if hasattr(progress_response, "data") else None
        
        # 2. Berechne neuen Zustand
        rating = int(q_vec.get("korrektheit", 0) * 4) + 1  # Für Rückwärtskompatibilität
        
        new_state = calculate_next_review_state(
            current_progress=current_progress,
            rating=rating,
            q_vec=q_vec  # Erweiterte Bewertung für genauere Schwierigkeitsberechnung
        )
        
        # 3. Speichere den neuen Zustand (Upsert) - angepasst an existierendes Schema
        upsert_data = {
            "student_id": student_id,
            "task_id": task_id,
            "difficulty": new_state.new_difficulty,
            "stability": new_state.new_stability,
            "last_reviewed_at": new_state.last_review_date.isoformat(),
            "next_due_date": new_state.next_due_date.date().isoformat()  # nur Datum, nicht Zeit
        }
        
        upsert_response = (
            service_client
            .table("student_mastery_progress")
            .upsert(upsert_data)
            .execute()
        )
        
        if hasattr(upsert_response, "error") and upsert_response.error:
            return False, f"Fehler beim Speichern des Fortschritts: {upsert_response.error.message}"
            
        return True, None

    except Exception as e:
        print(f"Exception in _update_mastery_progress: {traceback.format_exc()}")
        return False, f"Fehler bei der Fortschrittsberechnung: {e}"



# --- Feedback-Funktionen ---

def submit_feedback(feedback_type: str, message: str, client=None) -> bool:
    """Speichert anonymes Schüler-Feedback.
    
    Args:
        feedback_type: 'unterricht' oder 'plattform'
        message: Feedback-Nachricht
        client: Optional Supabase client instance
        
    Returns:
        bool: True bei Erfolg, False bei Fehler
    """
    try:
        # Use provided client or default
        if client is None:
            client = supabase_client
            
        # Debug: Print the values being inserted
        print(f"Attempting to insert feedback: type='{feedback_type}', message length={len(message)}")
        
        response = client.table('feedback') \
            .insert({
                'feedback_type': feedback_type,
                'message': message
            }) \
            .execute()
        
        # Debug: Check response
        if hasattr(response, 'data'):
            print(f"Feedback inserted successfully: {response.data}")
            return response.data is not None and len(response.data) > 0
        else:
            print(f"Unexpected response format: {response}")
            return False
            
    except Exception as e:
        print(f"Fehler beim Speichern des Feedbacks: {e}")
        print(f"Exception type: {type(e).__name__}")
        print(f"Exception details: {str(e)}")
        import traceback
        traceback.print_exc()
        return False

def get_all_feedback(client=None) -> list:
    """Holt alle Feedback-Einträge für Lehrer.
    
    Args:
        client: Optional Supabase client instance
    
    Returns:
        list: Liste aller Feedback-Einträge, sortiert nach Datum (neueste zuerst)
    """
    try:
        # Use provided client or default
        if client is None:
            client = supabase_client
            
        response = client.table('feedback') \
            .select('*') \
            .order('created_at', desc=True) \
            .execute()
        
        if hasattr(response, 'data'):
            return response.data
        return []
    except Exception as e:
        print(f"Fehler beim Abrufen des Feedbacks: {e}")
        print(f"Exception type: {type(e).__name__}")
        print(f"Exception details: {str(e)}")
        return []

# --- Weitere DB-Funktionen können hier hinzugefügt werden ---


def get_next_due_mastery_task(student_id: str, course_id: int) -> tuple[dict | None, str | None]:
    """
    Holt die nächste fällige Mastery-Aufgabe für einen Schüler in einem Kurs.
    Implementiert Interleaving durch Mischen aller fälligen Aufgaben.
    
    Args:
        student_id: ID des Schülers
        course_id: ID des Kurses
        
    Returns:
        tuple: (Aufgaben-Dict mit zusätzlichen Progress-Infos, None) bei Erfolg, 
               (None, Fehlermeldung) bei Fehler oder keine fällige Aufgabe.
    """
    try:
        from datetime import date
        import random
        
        # 1. Hole alle Mastery-Aufgaben des Kurses
        mastery_tasks, error = get_mastery_tasks_for_course(course_id)
        if error or not mastery_tasks:
            return None, error or "Keine Mastery-Aufgaben in diesem Kurs"
        
        # 2. Hole Progress-Daten für diesen Schüler
        progress_response = supabase_client.table('student_mastery_progress') \
            .select('*') \
            .eq('student_id', student_id) \
            .execute()
        
        progress_by_task = {}
        if hasattr(progress_response, 'data') and progress_response.data:
            for p in progress_response.data:
                progress_by_task[p['task_id']] = p
        
        # 3. Finde fällige Aufgaben
        today = date.today()
        due_tasks = []
        
        for task in mastery_tasks:
            task_id = task['id']
            
            # Wenn noch kein Progress existiert, ist die Aufgabe sofort fällig
            if task_id not in progress_by_task:
                due_tasks.append(task)
            else:
                progress = progress_by_task[task_id]
                due_date = progress.get('next_due_date')
                
                # Prüfe ob fällig
                if due_date:
                    if isinstance(due_date, str):
                        due_date = date.fromisoformat(due_date)
                    if due_date <= today:
                        # Füge Progress-Info zur Aufgabe hinzu
                        task['mastery_progress'] = progress
                        due_tasks.append(task)
        
        if not due_tasks:
            return None, "Keine Aufgaben fällig heute. Komm morgen wieder!"
        
        # 4. Interleaving: Wähle zufällig eine der fälligen Aufgaben
        # (In Zukunft könnte hier eine sophistiziertere Logik stehen)
        selected_task = random.choice(due_tasks)
        
        return selected_task, None
        
    except Exception as e:
        return None, f"Fehler beim Abrufen der nächsten Aufgabe: {e}"


def get_mastery_overview_for_teacher(course_id: int) -> tuple[list | None, str | None]:
    """
    Holt eine Übersicht aller Schüler und deren Mastery-Fortschritt für einen Kurs.
    
    Args:
        course_id: ID des Kurses
        
    Returns:
        tuple: (Liste mit Schüler-Fortschritt-Daten, None) bei Erfolg,
               (None, Fehlermeldung) bei Fehler.
    """
    try:
        # 1. Hole alle Schüler des Kurses
        students_response = supabase_client.table('course_student') \
            .select('student_id, profiles!inner(full_name, email)') \
            .eq('course_id', course_id) \
            .execute()
        
        if not hasattr(students_response, 'data'):
            return [], None
            
        students = students_response.data
        
        # 2. Hole alle Mastery-Tasks
        tasks, error = get_mastery_tasks_for_course(course_id)
        if error or not tasks:
            return [], None
            
        task_ids = [t['id'] for t in tasks]
        
        # 3. Hole Progress für alle Schüler
        progress_response = supabase_client.table('student_mastery_progress') \
            .select('*') \
            .in_('task_id', task_ids) \
            .execute()
        
        progress_by_student = {}
        if hasattr(progress_response, 'data'):
            for p in progress_response.data:
                student_id = p['student_id']
                if student_id not in progress_by_student:
                    progress_by_student[student_id] = []
                progress_by_student[student_id].append(p)
        
        # 4. Erstelle Übersicht
        overview = []
        for student in students:
            student_id = student['student_id']
            student_progress = progress_by_student.get(student_id, [])
            
            # Berechne Stats für diesen Schüler
            mastered = sum(1 for p in student_progress 
                          if p.get('status') == 'reviewing' and p.get('current_interval', 0) > 21)
            learning = sum(1 for p in student_progress if p.get('status') == 'learning')
            
            overview.append({
                'student_id': student_id,
                'student_name': student['profiles']['full_name'],
                'student_email': student['profiles']['email'],
                'total_tasks': len(tasks),
                'started_tasks': len(student_progress),
                'mastered_tasks': mastered,
                'learning_tasks': learning,
                'completion_rate': (mastered / len(tasks) * 100) if tasks else 0
            })
        
        # Sortiere nach Completion Rate
        overview.sort(key=lambda x: x['completion_rate'], reverse=True)
        
        return overview, None
        
    except Exception as e:
        return None, f"Fehler beim Abrufen der Lehrer-Übersicht: {e}"

# --- Optimierte Mastery Progress Funktionen ---

def get_mastery_progress_summary(student_id: str, course_id: str) -> tuple[dict | None, str | None]:
    """
    Optimierte Funktion für kompakte Mastery-Statistiken.
    Holt alle benötigten Daten in einem Query.
    """
    try:
        # Haupt-Statistiken über RPC
        query_result = supabase_client.rpc('get_mastery_summary', {
            'p_student_id': student_id,
            'p_course_id': course_id
        }).execute()
        
        if not query_result.data or len(query_result.data) == 0:
            # Fallback auf Standard-Werte wenn keine Daten
            return {
                'total': 0,
                'mastered': 0,
                'learning': 0,
                'not_started': 0,
                'due_today': 0,
                'avg_stability': 0.0,
                'streak': 0,
                'due_tomorrow': 0
            }, None
            
        stats = query_result.data[0]
        
        # Streak berechnen
        streak = calculate_learning_streak(student_id)
        stats['streak'] = streak
        
        # Morgen fällige Aufgaben
        tomorrow_result = supabase_client.rpc('get_due_tomorrow_count', {
            'p_student_id': student_id,
            'p_course_id': course_id
        }).execute()
        
        stats['due_tomorrow'] = tomorrow_result.data if tomorrow_result.data else 0
        
        return stats, None
        
    except Exception as e:
        print(f"Exception in get_mastery_progress_summary: {traceback.format_exc()}")
        return None, f"Fehler beim Abrufen der Statistiken: {e}"

def calculate_learning_streak(student_id: str) -> int:
    """
    Berechnet die aktuelle Lernstreak basierend auf submissions.
    Eine Streak wird fortgesetzt, wenn der Schüler an aufeinanderfolgenden Tagen
    mindestens eine Mastery-Aufgabe bearbeitet hat.
    """
    try:
        # Hole die letzten 30 Tage an Submissions
        thirty_days_ago = (datetime.now() - timedelta(days=30)).isoformat()
        
        response = supabase_client.table('submission') \
            .select('created_at') \
            .eq('student_id', student_id) \
            .gte('created_at', thirty_days_ago) \
            .order('created_at', desc=True) \
            .execute()
        
        if not hasattr(response, 'data') or not response.data:
            return 0
        
        # Gruppiere nach Datum
        dates_with_activity = set()
        for submission in response.data:
            date = datetime.fromisoformat(submission['created_at'].replace('Z', '+00:00')).date()
            dates_with_activity.add(date)
        
        # Prüfe Streak rückwärts vom heutigen Tag
        streak = 0
        current_date = datetime.now().date()
        
        while current_date in dates_with_activity:
            streak += 1
            current_date -= timedelta(days=1)
        
        return streak
        
    except Exception as e:
        print(f"Exception in calculate_learning_streak: {traceback.format_exc()}")
        return 0

# --- Feedback-Funktionen ---


