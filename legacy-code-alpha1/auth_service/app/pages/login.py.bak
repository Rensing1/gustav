# Copyright (c) 2025 GUSTAV Contributors
# SPDX-License-Identifier: MIT

"""
Login Page Routes for GUSTAV Auth Service
Implements dedicated login page with secure CSRF protection
"""
from fastapi import APIRouter, Request, Form, Response, HTTPException, Depends, Cookie
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from typing import Optional
import secrets
import logging
from pathlib import Path
from datetime import datetime, timedelta
from urllib.parse import urlparse
import time
import asyncio

from ..services.supabase_session_store_secure import SecureSessionStore
from ..config import settings
from ..dependencies import get_session_store
from ..models.auth import LoginRequest

logger = logging.getLogger(__name__)

# Setup templates directory
templates_dir = Path(__file__).parent.parent / "templates"
templates = Jinja2Templates(directory=str(templates_dir))

router = APIRouter()

def validate_redirect_url(next_url: str) -> str:
    """Validate redirect URL to prevent open redirect attacks.
    
    Args:
        next_url: The URL to validate
        
    Returns:
        Safe redirect URL (always internal)
    """
    if not next_url:
        return "/"
    
    parsed = urlparse(next_url)
    
    # No external redirects allowed
    if parsed.scheme or parsed.netloc:
        logger.warning(f"Blocked external redirect attempt: {next_url}")
        return "/"
    
    # Path must start with /
    if not parsed.path.startswith("/"):
        return "/"
    
    # Sanitize path to prevent traversal
    safe_path = parsed.path.replace("..", "")
    
    return safe_path


@router.get("/login", response_class=HTMLResponse)
async def login_page(
    request: Request,
    response: Response, 
    error: Optional[str] = None,
    next: Optional[str] = None,
    logout: Optional[str] = None
):
    """Render the login page with secure CSRF protection using Double Submit Cookie pattern"""
    # Generate CSRF token
    csrf_token = secrets.token_urlsafe(32)
    
    # Validate and sanitize redirect URL
    safe_next = validate_redirect_url(next)
    
    # Set CSRF cookie (Double Submit Cookie Pattern)
    response.set_cookie(
        key="csrf_token",
        value=csrf_token,
        httponly=True,
        secure=settings.ENVIRONMENT == "production",
        samesite="strict",
        max_age=3600,  # 1 hour
        path="/auth/"
    )
    
    # Define error messages
    error_messages = {
        "invalid_credentials": "E-Mail oder Passwort falsch.",
        "invalid_csrf": "Sicherheitsfehler. Bitte erneut versuchen.",
        "rate_limit": "Zu viele Anmeldeversuche. Bitte später erneut versuchen.",
        "email_not_confirmed": "E-Mail-Adresse noch nicht bestätigt.",
        "account_locked": "Account gesperrt. Bitte kontaktieren Sie den Support."
    }
    
    return templates.TemplateResponse("login.html", {
        "request": request,
        "csrf_token": csrf_token,
        "error": error,
        "error_messages": error_messages,
        "next": safe_next,
        "title": "GUSTAV Login",
        "logout_success": logout == "success"
    })


@router.post("/login")
async def process_login(
    request: Request,
    response: Response,
    email: str = Form(...),
    password: str = Form(...),
    csrf_form: str = Form(..., alias="csrf_token"),
    next: str = Form("/"),
    csrf_cookie: Optional[str] = Cookie(None, alias="csrf_token"),
    session_store: SecureSessionStore = Depends(get_session_store)
):
    """Process login with secure CSRF validation and session regeneration"""
    # Import here to avoid circular dependency
    from ..routes.auth import authenticate_user
    
    # Timing attack prevention - start timer
    start_time = time.time()
    
    # Validate CSRF (Double Submit Cookie)
    if not csrf_cookie or csrf_cookie != csrf_form:
        logger.warning(f"CSRF validation failed from {request.client.host if request.client else 'unknown'}")
        return RedirectResponse(
            url="/auth/login?error=invalid_csrf",
            status_code=303
        )
    
    # Validate and sanitize redirect URL
    safe_next = validate_redirect_url(next)
    
    # Session fixation prevention - get old session ID
    old_session_id = request.cookies.get(settings.COOKIE_NAME)
    
    try:
        # Use existing authentication logic
        login_data = LoginRequest(email=email, password=password)
        user_data = await authenticate_user(login_data, session_store)
        
        if not user_data:
            # Timing attack prevention - ensure constant response time
            elapsed = time.time() - start_time
            if elapsed < 0.5:  # Minimum 500ms response time
                await asyncio.sleep(0.5 - elapsed)
            
            return RedirectResponse(
                url="/auth/login?error=invalid_credentials",
                status_code=303
            )
        
        # Session fixation prevention - invalidate old session
        if old_session_id:
            try:
                await session_store.delete_session(old_session_id)
                logger.info(f"Invalidated old session {old_session_id[:8]}... for user {user_data['id']}")
            except Exception as e:
                logger.error(f"Failed to invalidate old session: {e}")
        
        # Create NEW session with NEW ID (session regeneration)
        session_data = await session_store.create_session(
            user_id=user_data["id"],
            email=user_data["email"],
            role=user_data.get("role", "user")
        )
        
        logger.info(f"Created new session {session_data['session_id'][:8]}... for user {user_data['id']}")
        
        # Set session cookie
        cookie_settings = settings.get_cookie_settings()
        response = RedirectResponse(url=safe_next, status_code=303)
        response.set_cookie(
            key=cookie_settings["key"],
            value=session_data["session_id"],
            max_age=cookie_settings["max_age"],
            httponly=cookie_settings["httponly"],
            secure=cookie_settings["secure"],
            samesite=cookie_settings["samesite"],
            domain=cookie_settings["domain"]
        )
        
        # Clear CSRF cookie after successful login
        response.delete_cookie(key="csrf_token", path="/auth/")
        
        logger.info(f"Successful login for {email} via login page with session regeneration")
        return response
        
    except HTTPException as e:
        # Handle specific errors with timing attack prevention
        elapsed = time.time() - start_time
        if elapsed < 0.5:
            await asyncio.sleep(0.5 - elapsed)
            
        error_code = "invalid_credentials"  # Default safe error
        
        if e.status_code == 429:
            error_code = "rate_limit"
        elif e.detail and "not confirmed" in e.detail.lower():
            error_code = "email_not_confirmed"
        elif e.detail and "locked" in e.detail.lower():
            error_code = "account_locked"
            
        return RedirectResponse(
            url=f"/auth/login?error={error_code}",
            status_code=303
        )
    except Exception as e:
        # Timing attack prevention
        elapsed = time.time() - start_time
        if elapsed < 0.5:
            await asyncio.sleep(0.5 - elapsed)
            
        logger.error(f"Login error: {e}")
        return RedirectResponse(
            url="/auth/login?error=invalid_credentials",
            status_code=303
        )


@router.get("/logout", response_class=HTMLResponse)
async def logout_page(request: Request, response: Response):
    """Render the logout confirmation page"""
    # Generate CSRF token for logout form
    csrf_token = secrets.token_urlsafe(32)
    
    # Set CSRF cookie (Double Submit Cookie Pattern)
    response.set_cookie(
        key="csrf_token",
        value=csrf_token,
        httponly=True,
        secure=settings.ENVIRONMENT == "production",
        samesite="strict",
        max_age=300,  # 5 minutes
        path="/auth/"
    )
    
    return templates.TemplateResponse("logout.html", {
        "request": request,
        "csrf_token": csrf_token,
        "title": "GUSTAV Logout"
    })


@router.post("/logout")
async def process_logout(
    request: Request,
    response: Response,
    csrf_form: str = Form(..., alias="csrf_token"),
    csrf_cookie: Optional[str] = Cookie(None, alias="csrf_token"),
    session_store: SecureSessionStore = Depends(get_session_store)
):
    """Process logout with CSRF validation"""
    # Validate CSRF (Double Submit Cookie)
    if not csrf_cookie or csrf_cookie != csrf_form:
        logger.warning(f"Logout CSRF validation failed from {request.client.host if request.client else 'unknown'}")
        return RedirectResponse(url="/", status_code=303)
    
    # Get session from cookie
    session_id = request.cookies.get(settings.COOKIE_NAME)
    
    if session_id:
        try:
            # Delete session from store
            await session_store.delete_session(session_id)
            logger.info(f"Session {session_id[:8]}... successfully logged out")
        except Exception as e:
            logger.error(f"Error deleting session: {e}")
    
    # Clear cookies
    response = RedirectResponse(url="/auth/login?logout=success", status_code=303)
    response.delete_cookie(
        key=settings.COOKIE_NAME,
        domain=settings.COOKIE_DOMAIN if settings.ENVIRONMENT == "production" else None
    )
    response.delete_cookie(key="csrf_token", path="/auth/")
    
    return response